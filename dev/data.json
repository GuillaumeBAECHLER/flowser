[
    {
        "block": {
            "id": "7bc42fe85d32ca513769a74f97f7e1a7bad6c9407f0d934c2aa645ef9cf613c7",
            "parentId": "0000000000000000000000000000000000000000000000000000000000000000",
            "height": 0,
            "timestamp": "2018-12-19T22:32:30.000Z",
            "collectionGuarantees": [],
            "blockSeals": [],
            "signatures": [
                ""
            ]
        },
        "collections": [],
        "transactions": [],
        "accounts": [],
        "events": []
    },
    {
        "block": {
            "id": "af48e16955fe543a6828646d8eb5f38fc48eb7584ba97a158bd29a2390e2cbf1",
            "parentId": "7bc42fe85d32ca513769a74f97f7e1a7bad6c9407f0d934c2aa645ef9cf613c7",
            "height": 1,
            "timestamp": "2021-10-01T17:05:22.908Z",
            "collectionGuarantees": [
                {
                    "collectionId": "8c8a128bd12fbc645796d31e2eec05a2bf2ecf384431128e9792b39d62825bb1",
                    "signatures": [
                        ""
                    ]
                }
            ],
            "blockSeals": [],
            "signatures": [
                ""
            ]
        },
        "collections": [
            {
                "blockId": "af48e16955fe543a6828646d8eb5f38fc48eb7584ba97a158bd29a2390e2cbf1",
                "id": "8c8a128bd12fbc645796d31e2eec05a2bf2ecf384431128e9792b39d62825bb1",
                "transactionIds": [
                    "97f773b847f9c4231ed80d930cfb86baeee35cc0af02df792d17ddcdcbc07ef2"
                ]
            }
        ],
        "transactions": [
            {
                "id": "97f773b847f9c4231ed80d930cfb86baeee35cc0af02df792d17ddcdcbc07ef2",
                "script": "\n\ttransaction(name: String, code: String ) {\n\t\tprepare(signer: AuthAccount) {\n\t\t\tsigner.contracts.add(name: name, code: code.decodeHex() )\n\t\t}\n\t}",
                "args": [
                    {
                        "type": "String",
                        "value": "HelloWorld"
                    },
                    {
                        "type": "String",
                        "value": "2f2f2048656c6c6f576f726c642e6364630a2f2f0a2f2f2057656c636f6d6520746f20436164656e6365212054686973206973206f6e65206f66207468652073696d706c6573742070726f6772616d7320796f752063616e206465706c6f79206f6e20466c6f772e0a2f2f0a2f2f205468652048656c6c6f576f726c6420636f6e747261637420636f6e7461696e7320612073696e676c6520737472696e67206669656c6420616e642061207075626c6963206765747465722066756e6374696f6e2e0a2f2f0a2f2f20466f6c6c6f7720746865202248656c6c6f2c20576f726c642122207475746f7269616c20746f206c6561726e206d6f72653a2068747470733a2f2f646f63732e6f6e666c6f772e6f72672f646f63732f68656c6c6f2d776f726c640a0a70756220636f6e74726163742048656c6c6f576f726c64207b0a0a202020202f2f204465636c6172652061207075626c6963206669656c64206f66207479706520537472696e672e0a202020202f2f0a202020202f2f20416c6c206669656c6473206d75737420626520696e697469616c697a656420696e2074686520696e697428292066756e6374696f6e2e0a20202020707562206c6574206772656574696e673a20537472696e670a0a20202020707562206576656e7420477265657428783a20537472696e67290a0a202020202f2f2054686520696e697428292066756e6374696f6e2069732072657175697265642069662074686520636f6e747261637420636f6e7461696e7320616e79206669656c64732e0a20202020696e69742829207b0a202020202020202073656c662e6772656574696e67203d202248656c6c6f2c20576f726c6421220a202020207d0a0a202020202f2f205075626c69632066756e6374696f6e20746861742072657475726e73206f757220667269656e646c79206772656574696e67210a202020207075622066756e2068656c6c6f28293a20537472696e67207b0a2020202020202020656d697420477265657428783a2073656c662e6772656574696e67290a202020202020202072657475726e2073656c662e6772656574696e670a202020207d0a7d0a"
                    }
                ],
                "referenceBlockId": "7bc42fe85d32ca513769a74f97f7e1a7bad6c9407f0d934c2aa645ef9cf613c7",
                "gasLimit": 9999,
                "proposalKey": {
                    "address": "f8d6e0586b0a20c7",
                    "keyId": 0,
                    "sequenceNumber": 0
                },
                "payer": "f8d6e0586b0a20c7",
                "authorizers": [
                    "f8d6e0586b0a20c7"
                ],
                "payloadSignatures": [],
                "envelopeSignatures": [
                    {
                        "address": "f8d6e0586b0a20c7",
                        "keyId": 0,
                        "signature": "b14b91e984fee4ae0aec4f35a49e598a4ef79837eea3643d9600d8751ac1192d2b3840b0108c701421d68e4176d5600f986a7379a9b438443266fa39b265d83a"
                    }
                ],
                "status": {
                    "status": 4,
                    "statusCode": 0,
                    "errorMessage": "",
                    "eventsCount": 1
                }
            }
        ],
        "accounts": [
            {
                "address": "0xf8d6e0586b0a20c7",
                "balance": 999999999999400000,
                "code": "",
                "contracts": {
                    "FlowServiceAccount": "import FungibleToken from 0xee82856bf20e2aa6\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FlowFees from 0xe5a8b7f23e8b548f\nimport FlowStorageFees from 0xf8d6e0586b0a20c7\n\npub contract FlowServiceAccount {\n\n    pub event TransactionFeeUpdated(newFee: UFix64)\n\n    pub event AccountCreationFeeUpdated(newFee: UFix64)\n\n    pub event AccountCreatorAdded(accountCreator: Address)\n\n    pub event AccountCreatorRemoved(accountCreator: Address)\n\n    pub event IsAccountCreationRestrictedUpdated(isRestricted: Bool)\n\n    /// A fixed-rate fee charged to execute a transaction\n    pub var transactionFee: UFix64\n\n    /// A fixed-rate fee charged to create a new account\n    pub var accountCreationFee: UFix64\n\n    /// The list of account addresses that have permission to create accounts\n    access(contract) var accountCreators: {Address: Bool}\n\n    /// Initialize an account with a FlowToken Vault and publish capabilities.\n    pub fun initDefaultToken(_ acct: AuthAccount) {\n        // Create a new FlowToken Vault and save it in storage\n        acct.save(<-FlowToken.createEmptyVault(), to: /storage/flowTokenVault)\n\n        // Create a public capability to the Vault that only exposes\n        // the deposit function through the Receiver interface\n        acct.link<&FlowToken.Vault{FungibleToken.Receiver}>(\n            /public/flowTokenReceiver,\n            target: /storage/flowTokenVault\n        )\n\n        // Create a public capability to the Vault that only exposes\n        // the balance field through the Balance interface\n        acct.link<&FlowToken.Vault{FungibleToken.Balance}>(\n            /public/flowTokenBalance,\n            target: /storage/flowTokenVault\n        )\n    }\n\n    /// Get the default token balance on an account\n    pub fun defaultTokenBalance(_ acct: PublicAccount): UFix64 {\n        let balanceRef = acct\n            .getCapability(/public/flowTokenBalance)\n            .borrow<&FlowToken.Vault{FungibleToken.Balance}>()!\n\n        return balanceRef.balance\n    }\n\n    /// Return a reference to the default token vault on an account\n    pub fun defaultTokenVault(_ acct: AuthAccount): &FlowToken.Vault {\n        return acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Unable to borrow reference to the default token vault\")\n    }\n\n    /// Called when a transaction is submitted to deduct the fee\n    /// from the AuthAccount that submitted it\n    pub fun deductTransactionFee(_ acct: AuthAccount) {\n        if self.transactionFee == UFix64(0) {\n            return\n        }\n\n        let tokenVault = self.defaultTokenVault(acct)\n        let feeVault <- tokenVault.withdraw(amount: self.transactionFee)\n\n        FlowFees.deposit(from: <-feeVault)\n    }\n\n    /// - Deducts the account creation fee from a payer account.\n    /// - Inits the default token.\n    /// - Inits account storage capacity.\n    pub fun setupNewAccount(newAccount: AuthAccount, payer: AuthAccount) {\n        if !FlowServiceAccount.isAccountCreator(payer.address) {\n            panic(\"Account not authorized to create accounts\")\n        }\n\n\n        if self.accountCreationFee < FlowStorageFees.minimumStorageReservation {\n            panic(\"Account creation fees setup incorrectly\")\n        }\n\n        let tokenVault = self.defaultTokenVault(payer)\n        let feeVault <- tokenVault.withdraw(amount: self.accountCreationFee)\n        let storageFeeVault <- (feeVault.withdraw(amount: FlowStorageFees.minimumStorageReservation) as! @FlowToken.Vault)\n        FlowFees.deposit(from: <-feeVault)\n\n        FlowServiceAccount.initDefaultToken(newAccount)\n\n        let vaultRef = FlowServiceAccount.defaultTokenVault(newAccount)\n\n        vaultRef.deposit(from: <-storageFeeVault)\n    }\n\n    /// Returns true if the given address is permitted to create accounts, false otherwise\n    pub fun isAccountCreator(_ address: Address): Bool {\n        // If account creation is not restricted, then anyone can create an account\n        if !self.isAccountCreationRestricted() {\n            return true\n        }\n        return self.accountCreators[address] ?? false\n    }\n\n    /// Is true if new acconts can only be created by approved accounts `self.accountCreators`\n    pub fun isAccountCreationRestricted(): Bool {\n        return self.account.copy<Bool>(from: /storage/isAccountCreationRestricted) ?? false\n    }\n\n    // Authorization resource to change the fields of the contract\n    /// Returns all addresses permitted to create accounts\n    pub fun getAccountCreators(): [Address] {\n        return self.accountCreators.keys\n    }\n\n    /// Authorization resource to change the fields of the contract\n    pub resource Administrator {\n\n        /// Sets the transaction fee\n        pub fun setTransactionFee(_ newFee: UFix64) {\n            FlowServiceAccount.transactionFee = newFee\n            emit TransactionFeeUpdated(newFee: newFee)\n        }\n\n        /// Sets the account creation fee\n        pub fun setAccountCreationFee(_ newFee: UFix64) {\n            FlowServiceAccount.accountCreationFee = newFee\n            emit AccountCreationFeeUpdated(newFee: newFee)\n        }\n\n        /// Adds an account address as an authorized account creator\n        pub fun addAccountCreator(_ accountCreator: Address) {\n            FlowServiceAccount.accountCreators[accountCreator] = true\n            emit AccountCreatorAdded(accountCreator: accountCreator)\n        }\n\n        /// Removes an account address as an authorized account creator\n        pub fun removeAccountCreator(_ accountCreator: Address) {\n            FlowServiceAccount.accountCreators.remove(key: accountCreator)\n            emit AccountCreatorRemoved(accountCreator: accountCreator)\n        }\n\n         pub fun setIsAccountCreationRestricted(_ enabled: Bool) {\n            let path = /storage/isAccountCreationRestricted\n            let oldValue = FlowServiceAccount.account.load<Bool>(from: path)\n            FlowServiceAccount.account.save<Bool>(enabled, to: path)\n            if enabled != oldValue {\n                emit IsAccountCreationRestrictedUpdated(isRestricted: enabled)\n            }\n        }\n    }\n\n    init() {\n        self.transactionFee = 0.0\n        self.accountCreationFee = 0.0\n\n        self.accountCreators = {}\n\n        let admin <- create Administrator()\n        admin.addAccountCreator(self.account.address)\n\n        self.account.save(<-admin, to: /storage/flowServiceAdmin)\n    }\n}\n",
                    "FlowStorageFees": "/*\n * The FlowStorageFees smart contract\n *\n * An account's storage capacity determines up to how much storage on chain it can use. \n * A storage capacity is calculated by multiplying the amount of reserved flow with `StorageFee.storageMegaBytesPerReservedFLOW`\n * The minimum amount of flow tokens reserved for storage capacity is `FlowStorageFees.minimumStorageReservation` this is paid during account creation, by the creator.\n * \n * At the end of all transactions, any account that had any value changed in their storage \n * has their storage capacity checked against their storage used and their main flow token vault against the minimum reservation.\n * If any account fails this check the transaction wil fail.\n * \n * An account moving/deleting its `FlowToken.Vault` resource will result \n * in the transaction failing because the account will have no storage capacity.\n * \n */\n\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FlowToken from 0x0ae53cb6e3f42a79\n\npub contract FlowStorageFees {\n\n    // Emitted when the amount of storage capacity an account has per reserved Flow token changes\n    pub event StorageMegaBytesPerReservedFLOWChanged(_ storageMegaBytesPerReservedFLOW: UFix64)\n\n    // Emitted when the minimum amount of Flow tokens that an account needs to have reserved for storage capacity changes.\n    pub event MinimumStorageReservationChanged(_ minimumStorageReservation: UFix64)\n\n    // Defines how much storage capacity every account has per reserved Flow token.\n    // definition is written per unit of flow instead of the inverse, \n    // so there is no loss of precision calculating storage from flow, \n    // but there is loss of precision when calculating flow per storage.\n    pub var storageMegaBytesPerReservedFLOW: UFix64\n\n    // Defines the minimum amount of Flow tokens that every account needs to have reserved for storage capacity.\n    // If an account has less then this amount reserved by the end of any transaction it participated in, the transaction will fail.\n    pub var minimumStorageReservation: UFix64\n\n    // An administrator resource that can change the parameters of the FlowStorageFees smart contract.\n    pub resource Administrator {\n\n        // Changes the amount of storage capacity an account has per accounts' reserved storage FLOW.\n        pub fun setStorageMegaBytesPerReservedFLOW(_ storageMegaBytesPerReservedFLOW: UFix64) {\n            if FlowStorageFees.storageMegaBytesPerReservedFLOW == storageMegaBytesPerReservedFLOW {\n              return\n            }\n            FlowStorageFees.storageMegaBytesPerReservedFLOW = storageMegaBytesPerReservedFLOW\n            emit StorageMegaBytesPerReservedFLOWChanged(storageMegaBytesPerReservedFLOW)\n        }\n\n        // Changes the minimum amount of FLOW an account has to have reserved.\n        pub fun setMinimumStorageReservation(_ minimumStorageReservation: UFix64) {\n            if FlowStorageFees.minimumStorageReservation == minimumStorageReservation {\n              return\n            }\n            FlowStorageFees.minimumStorageReservation = minimumStorageReservation\n            emit MinimumStorageReservationChanged(minimumStorageReservation)\n        }\n\n        access(contract) init(){}\n    }\n\n    // Returns megabytes\n    pub fun calculateAccountCapacity(_ accountAddress: Address): UFix64 {\n        let balanceRef = getAccount(accountAddress)\n            .getCapability<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance)!\n            .borrow() ?? panic(\"Could not borrow FLOW balance capability\")\n\n        // get address token balance\n        if balanceRef.balance < self.minimumStorageReservation {\n            // if < then minimum return 0\n            return 0.0\n        } else {\n            // return balance multiplied with megabytes per flow \n            return balanceRef.balance * self.storageMegaBytesPerReservedFLOW\n        }\n    }\n\n    // Amount in Flow tokens\n    // Returns megabytes\n    pub fun flowToStorageCapacity(_ amount: UFix64): UFix64 {\n        return amount * FlowStorageFees.storageMegaBytesPerReservedFLOW\n    }\n\n    // Amount in megabytes\n    // Returns Flow tokens\n    pub fun storageCapacityToFlow(_ amount: UFix64): UFix64 {\n        if FlowStorageFees.storageMegaBytesPerReservedFLOW == 0.0 as UFix64 {\n            return 0.0 as UFix64\n        }\n        // possible loss of precision\n        // putting the result back into `flowToStorageCapacity` might not yield the same result\n        return amount / FlowStorageFees.storageMegaBytesPerReservedFLOW\n    }\n\n    // converts storage used from UInt64 Bytes to UFix64 Megabytes.\n    pub fun convertUInt64StorageBytesToUFix64Megabytes(_ storage: UInt64): UFix64 {\n        // safe convert UInt64 to UFix64 (without overflow)\n        let f = UFix64(storage % 100000000 as UInt64) * 0.00000001 as UFix64 + UFix64(storage / 100000000 as UInt64)\n        // decimal point correction. Megabytes to bytes have a conversion of 10^-6 while UFix64 minimum value is 10^-8\n        let storageMb = f * 100.0 as UFix64\n        return storageMb\n    }\n\n    // Gets \"available\" balance of an account\n    // The available balance is its default token balance minus what is reserved for storage.\n    pub fun defaultTokenAvailableBalance(_ accountAddress: Address): UFix64 {\n        //get balance of account\n        let acct = getAccount(accountAddress)\n        let balanceRef = acct\n            .getCapability(/public/flowTokenBalance)\n            .borrow<&FlowToken.Vault{FungibleToken.Balance}>()!\n        let balance = balanceRef.balance\n\n        // get how much should be reserved for storage\n        var reserved = self.storageCapacityToFlow(self.convertUInt64StorageBytesToUFix64Megabytes(acct.storageUsed))\n        // at least self.minimumStorageReservation should be reserved\n        if reserved < self.minimumStorageReservation {\n            reserved = self.minimumStorageReservation\n        }\n\n        // balance could be less that what the account needs to have reserved for storage. In that case return 0.\n        if reserved > balance {\n            return 0.0\n        }\n        \n        return balance - reserved\n    }\n\n    init() {\n        self.storageMegaBytesPerReservedFLOW = 1.0 // 1 Mb per 1 Flow token\n        self.minimumStorageReservation = 0.0 // or 0 kb of minimum storage reservation\n\n        let admin <- create Administrator()\n        self.account.save(<-admin, to: /storage/storageFeesAdmin)\n    }\n}",
                    "HelloWorld": "// HelloWorld.cdc\n//\n// Welcome to Cadence! This is one of the simplest programs you can deploy on Flow.\n//\n// The HelloWorld contract contains a single string field and a public getter function.\n//\n// Follow the \"Hello, World!\" tutorial to learn more: https://docs.onflow.org/docs/hello-world\n\npub contract HelloWorld {\n\n    // Declare a public field of type String.\n    //\n    // All fields must be initialized in the init() function.\n    pub let greeting: String\n\n    pub event Greet(x: String)\n\n    // The init() function is required if the contract contains any fields.\n    init() {\n        self.greeting = \"Hello, World!\"\n    }\n\n    // Public function that returns our friendly greeting!\n    pub fun hello(): String {\n        emit Greet(x: self.greeting)\n        return self.greeting\n    }\n}\n"
                },
                "keys": [
                    {
                        "index": 0,
                        "publicKey": "ee69a34c1a8c4fdc5d55bd1a78174ef1fd5f579243ecb032672cbb23845973d4b8c393078807b820dcf6a4573dbca61dcfffc2ceca1af3d2bc03eac31fdbe67c",
                        "signAlgo": 2,
                        "hashAlgo": 3,
                        "weight": 1000,
                        "sequenceNumber": 8,
                        "revoked": false
                    }
                ]
            }
        ],
        "events": [
            [
                {
                    "transactionId": "97f773b847f9c4231ed80d930cfb86baeee35cc0af02df792d17ddcdcbc07ef2",
                    "type": "flow.AccountContractAdded",
                    "transactionIndex": 1,
                    "eventIndex": 0,
                    "data": {
                        "address": "0xf8d6e0586b0a20c7",
                        "codeHash": [
                            70,
                            232,
                            67,
                            4,
                            254,
                            86,
                            228,
                            7,
                            50,
                            231,
                            40,
                            97,
                            73,
                            176,
                            162,
                            31,
                            161,
                            60,
                            181,
                            91,
                            248,
                            254,
                            48,
                            242,
                            93,
                            105,
                            135,
                            202,
                            234,
                            90,
                            34,
                            27
                        ],
                        "contract": "HelloWorld"
                    }
                }
            ]
        ]
    },
    {
        "block": {
            "id": "300f74117e6af5d7f6ef247fab36532761f91cc1b1b1c298d094a2cb53ff1bf1",
            "parentId": "af48e16955fe543a6828646d8eb5f38fc48eb7584ba97a158bd29a2390e2cbf1",
            "height": 2,
            "timestamp": "2021-10-01T17:05:28.245Z",
            "collectionGuarantees": [
                {
                    "collectionId": "26189696381e501925e3e76140cf03e2f38db213eb01d3db1963ac71106d8c53",
                    "signatures": [
                        ""
                    ]
                }
            ],
            "blockSeals": [],
            "signatures": [
                ""
            ]
        },
        "collections": [
            {
                "blockId": "300f74117e6af5d7f6ef247fab36532761f91cc1b1b1c298d094a2cb53ff1bf1",
                "id": "26189696381e501925e3e76140cf03e2f38db213eb01d3db1963ac71106d8c53",
                "transactionIds": [
                    "d6b543cd5ae4307c741a4ed87ce5077cd23075d633b3732ad843ccd29dd516bf"
                ]
            }
        ],
        "transactions": [
            {
                "id": "d6b543cd5ae4307c741a4ed87ce5077cd23075d633b3732ad843ccd29dd516bf",
                "script": "import HelloWorld from 0xf8d6e0586b0a20c7\n\ntransaction {\n\n  prepare(acct: AuthAccount) {}\n\n  execute {\n    log(HelloWorld.hello())\n  }\n}\n",
                "args": [],
                "referenceBlockId": "af48e16955fe543a6828646d8eb5f38fc48eb7584ba97a158bd29a2390e2cbf1",
                "gasLimit": 1000,
                "proposalKey": {
                    "address": "f8d6e0586b0a20c7",
                    "keyId": 0,
                    "sequenceNumber": 1
                },
                "payer": "f8d6e0586b0a20c7",
                "authorizers": [
                    "f8d6e0586b0a20c7"
                ],
                "payloadSignatures": [],
                "envelopeSignatures": [
                    {
                        "address": "f8d6e0586b0a20c7",
                        "keyId": 0,
                        "signature": "b03d848445f1ba652c79bd8f411d5e1c54019bf3893dc02a25f649dae24027c152d97cfde2568ae96dde9eea0e89f5c81972d1e307d7379077e3933219d43b4e"
                    }
                ],
                "status": {
                    "status": 4,
                    "statusCode": 0,
                    "errorMessage": "",
                    "eventsCount": 1
                }
            }
        ],
        "accounts": [
            {
                "address": "0xf8d6e0586b0a20c7",
                "balance": 999999999999400000,
                "code": "",
                "contracts": {
                    "FlowServiceAccount": "import FungibleToken from 0xee82856bf20e2aa6\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FlowFees from 0xe5a8b7f23e8b548f\nimport FlowStorageFees from 0xf8d6e0586b0a20c7\n\npub contract FlowServiceAccount {\n\n    pub event TransactionFeeUpdated(newFee: UFix64)\n\n    pub event AccountCreationFeeUpdated(newFee: UFix64)\n\n    pub event AccountCreatorAdded(accountCreator: Address)\n\n    pub event AccountCreatorRemoved(accountCreator: Address)\n\n    pub event IsAccountCreationRestrictedUpdated(isRestricted: Bool)\n\n    /// A fixed-rate fee charged to execute a transaction\n    pub var transactionFee: UFix64\n\n    /// A fixed-rate fee charged to create a new account\n    pub var accountCreationFee: UFix64\n\n    /// The list of account addresses that have permission to create accounts\n    access(contract) var accountCreators: {Address: Bool}\n\n    /// Initialize an account with a FlowToken Vault and publish capabilities.\n    pub fun initDefaultToken(_ acct: AuthAccount) {\n        // Create a new FlowToken Vault and save it in storage\n        acct.save(<-FlowToken.createEmptyVault(), to: /storage/flowTokenVault)\n\n        // Create a public capability to the Vault that only exposes\n        // the deposit function through the Receiver interface\n        acct.link<&FlowToken.Vault{FungibleToken.Receiver}>(\n            /public/flowTokenReceiver,\n            target: /storage/flowTokenVault\n        )\n\n        // Create a public capability to the Vault that only exposes\n        // the balance field through the Balance interface\n        acct.link<&FlowToken.Vault{FungibleToken.Balance}>(\n            /public/flowTokenBalance,\n            target: /storage/flowTokenVault\n        )\n    }\n\n    /// Get the default token balance on an account\n    pub fun defaultTokenBalance(_ acct: PublicAccount): UFix64 {\n        let balanceRef = acct\n            .getCapability(/public/flowTokenBalance)\n            .borrow<&FlowToken.Vault{FungibleToken.Balance}>()!\n\n        return balanceRef.balance\n    }\n\n    /// Return a reference to the default token vault on an account\n    pub fun defaultTokenVault(_ acct: AuthAccount): &FlowToken.Vault {\n        return acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Unable to borrow reference to the default token vault\")\n    }\n\n    /// Called when a transaction is submitted to deduct the fee\n    /// from the AuthAccount that submitted it\n    pub fun deductTransactionFee(_ acct: AuthAccount) {\n        if self.transactionFee == UFix64(0) {\n            return\n        }\n\n        let tokenVault = self.defaultTokenVault(acct)\n        let feeVault <- tokenVault.withdraw(amount: self.transactionFee)\n\n        FlowFees.deposit(from: <-feeVault)\n    }\n\n    /// - Deducts the account creation fee from a payer account.\n    /// - Inits the default token.\n    /// - Inits account storage capacity.\n    pub fun setupNewAccount(newAccount: AuthAccount, payer: AuthAccount) {\n        if !FlowServiceAccount.isAccountCreator(payer.address) {\n            panic(\"Account not authorized to create accounts\")\n        }\n\n\n        if self.accountCreationFee < FlowStorageFees.minimumStorageReservation {\n            panic(\"Account creation fees setup incorrectly\")\n        }\n\n        let tokenVault = self.defaultTokenVault(payer)\n        let feeVault <- tokenVault.withdraw(amount: self.accountCreationFee)\n        let storageFeeVault <- (feeVault.withdraw(amount: FlowStorageFees.minimumStorageReservation) as! @FlowToken.Vault)\n        FlowFees.deposit(from: <-feeVault)\n\n        FlowServiceAccount.initDefaultToken(newAccount)\n\n        let vaultRef = FlowServiceAccount.defaultTokenVault(newAccount)\n\n        vaultRef.deposit(from: <-storageFeeVault)\n    }\n\n    /// Returns true if the given address is permitted to create accounts, false otherwise\n    pub fun isAccountCreator(_ address: Address): Bool {\n        // If account creation is not restricted, then anyone can create an account\n        if !self.isAccountCreationRestricted() {\n            return true\n        }\n        return self.accountCreators[address] ?? false\n    }\n\n    /// Is true if new acconts can only be created by approved accounts `self.accountCreators`\n    pub fun isAccountCreationRestricted(): Bool {\n        return self.account.copy<Bool>(from: /storage/isAccountCreationRestricted) ?? false\n    }\n\n    // Authorization resource to change the fields of the contract\n    /// Returns all addresses permitted to create accounts\n    pub fun getAccountCreators(): [Address] {\n        return self.accountCreators.keys\n    }\n\n    /// Authorization resource to change the fields of the contract\n    pub resource Administrator {\n\n        /// Sets the transaction fee\n        pub fun setTransactionFee(_ newFee: UFix64) {\n            FlowServiceAccount.transactionFee = newFee\n            emit TransactionFeeUpdated(newFee: newFee)\n        }\n\n        /// Sets the account creation fee\n        pub fun setAccountCreationFee(_ newFee: UFix64) {\n            FlowServiceAccount.accountCreationFee = newFee\n            emit AccountCreationFeeUpdated(newFee: newFee)\n        }\n\n        /// Adds an account address as an authorized account creator\n        pub fun addAccountCreator(_ accountCreator: Address) {\n            FlowServiceAccount.accountCreators[accountCreator] = true\n            emit AccountCreatorAdded(accountCreator: accountCreator)\n        }\n\n        /// Removes an account address as an authorized account creator\n        pub fun removeAccountCreator(_ accountCreator: Address) {\n            FlowServiceAccount.accountCreators.remove(key: accountCreator)\n            emit AccountCreatorRemoved(accountCreator: accountCreator)\n        }\n\n         pub fun setIsAccountCreationRestricted(_ enabled: Bool) {\n            let path = /storage/isAccountCreationRestricted\n            let oldValue = FlowServiceAccount.account.load<Bool>(from: path)\n            FlowServiceAccount.account.save<Bool>(enabled, to: path)\n            if enabled != oldValue {\n                emit IsAccountCreationRestrictedUpdated(isRestricted: enabled)\n            }\n        }\n    }\n\n    init() {\n        self.transactionFee = 0.0\n        self.accountCreationFee = 0.0\n\n        self.accountCreators = {}\n\n        let admin <- create Administrator()\n        admin.addAccountCreator(self.account.address)\n\n        self.account.save(<-admin, to: /storage/flowServiceAdmin)\n    }\n}\n",
                    "FlowStorageFees": "/*\n * The FlowStorageFees smart contract\n *\n * An account's storage capacity determines up to how much storage on chain it can use. \n * A storage capacity is calculated by multiplying the amount of reserved flow with `StorageFee.storageMegaBytesPerReservedFLOW`\n * The minimum amount of flow tokens reserved for storage capacity is `FlowStorageFees.minimumStorageReservation` this is paid during account creation, by the creator.\n * \n * At the end of all transactions, any account that had any value changed in their storage \n * has their storage capacity checked against their storage used and their main flow token vault against the minimum reservation.\n * If any account fails this check the transaction wil fail.\n * \n * An account moving/deleting its `FlowToken.Vault` resource will result \n * in the transaction failing because the account will have no storage capacity.\n * \n */\n\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FlowToken from 0x0ae53cb6e3f42a79\n\npub contract FlowStorageFees {\n\n    // Emitted when the amount of storage capacity an account has per reserved Flow token changes\n    pub event StorageMegaBytesPerReservedFLOWChanged(_ storageMegaBytesPerReservedFLOW: UFix64)\n\n    // Emitted when the minimum amount of Flow tokens that an account needs to have reserved for storage capacity changes.\n    pub event MinimumStorageReservationChanged(_ minimumStorageReservation: UFix64)\n\n    // Defines how much storage capacity every account has per reserved Flow token.\n    // definition is written per unit of flow instead of the inverse, \n    // so there is no loss of precision calculating storage from flow, \n    // but there is loss of precision when calculating flow per storage.\n    pub var storageMegaBytesPerReservedFLOW: UFix64\n\n    // Defines the minimum amount of Flow tokens that every account needs to have reserved for storage capacity.\n    // If an account has less then this amount reserved by the end of any transaction it participated in, the transaction will fail.\n    pub var minimumStorageReservation: UFix64\n\n    // An administrator resource that can change the parameters of the FlowStorageFees smart contract.\n    pub resource Administrator {\n\n        // Changes the amount of storage capacity an account has per accounts' reserved storage FLOW.\n        pub fun setStorageMegaBytesPerReservedFLOW(_ storageMegaBytesPerReservedFLOW: UFix64) {\n            if FlowStorageFees.storageMegaBytesPerReservedFLOW == storageMegaBytesPerReservedFLOW {\n              return\n            }\n            FlowStorageFees.storageMegaBytesPerReservedFLOW = storageMegaBytesPerReservedFLOW\n            emit StorageMegaBytesPerReservedFLOWChanged(storageMegaBytesPerReservedFLOW)\n        }\n\n        // Changes the minimum amount of FLOW an account has to have reserved.\n        pub fun setMinimumStorageReservation(_ minimumStorageReservation: UFix64) {\n            if FlowStorageFees.minimumStorageReservation == minimumStorageReservation {\n              return\n            }\n            FlowStorageFees.minimumStorageReservation = minimumStorageReservation\n            emit MinimumStorageReservationChanged(minimumStorageReservation)\n        }\n\n        access(contract) init(){}\n    }\n\n    // Returns megabytes\n    pub fun calculateAccountCapacity(_ accountAddress: Address): UFix64 {\n        let balanceRef = getAccount(accountAddress)\n            .getCapability<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance)!\n            .borrow() ?? panic(\"Could not borrow FLOW balance capability\")\n\n        // get address token balance\n        if balanceRef.balance < self.minimumStorageReservation {\n            // if < then minimum return 0\n            return 0.0\n        } else {\n            // return balance multiplied with megabytes per flow \n            return balanceRef.balance * self.storageMegaBytesPerReservedFLOW\n        }\n    }\n\n    // Amount in Flow tokens\n    // Returns megabytes\n    pub fun flowToStorageCapacity(_ amount: UFix64): UFix64 {\n        return amount * FlowStorageFees.storageMegaBytesPerReservedFLOW\n    }\n\n    // Amount in megabytes\n    // Returns Flow tokens\n    pub fun storageCapacityToFlow(_ amount: UFix64): UFix64 {\n        if FlowStorageFees.storageMegaBytesPerReservedFLOW == 0.0 as UFix64 {\n            return 0.0 as UFix64\n        }\n        // possible loss of precision\n        // putting the result back into `flowToStorageCapacity` might not yield the same result\n        return amount / FlowStorageFees.storageMegaBytesPerReservedFLOW\n    }\n\n    // converts storage used from UInt64 Bytes to UFix64 Megabytes.\n    pub fun convertUInt64StorageBytesToUFix64Megabytes(_ storage: UInt64): UFix64 {\n        // safe convert UInt64 to UFix64 (without overflow)\n        let f = UFix64(storage % 100000000 as UInt64) * 0.00000001 as UFix64 + UFix64(storage / 100000000 as UInt64)\n        // decimal point correction. Megabytes to bytes have a conversion of 10^-6 while UFix64 minimum value is 10^-8\n        let storageMb = f * 100.0 as UFix64\n        return storageMb\n    }\n\n    // Gets \"available\" balance of an account\n    // The available balance is its default token balance minus what is reserved for storage.\n    pub fun defaultTokenAvailableBalance(_ accountAddress: Address): UFix64 {\n        //get balance of account\n        let acct = getAccount(accountAddress)\n        let balanceRef = acct\n            .getCapability(/public/flowTokenBalance)\n            .borrow<&FlowToken.Vault{FungibleToken.Balance}>()!\n        let balance = balanceRef.balance\n\n        // get how much should be reserved for storage\n        var reserved = self.storageCapacityToFlow(self.convertUInt64StorageBytesToUFix64Megabytes(acct.storageUsed))\n        // at least self.minimumStorageReservation should be reserved\n        if reserved < self.minimumStorageReservation {\n            reserved = self.minimumStorageReservation\n        }\n\n        // balance could be less that what the account needs to have reserved for storage. In that case return 0.\n        if reserved > balance {\n            return 0.0\n        }\n        \n        return balance - reserved\n    }\n\n    init() {\n        self.storageMegaBytesPerReservedFLOW = 1.0 // 1 Mb per 1 Flow token\n        self.minimumStorageReservation = 0.0 // or 0 kb of minimum storage reservation\n\n        let admin <- create Administrator()\n        self.account.save(<-admin, to: /storage/storageFeesAdmin)\n    }\n}",
                    "HelloWorld": "// HelloWorld.cdc\n//\n// Welcome to Cadence! This is one of the simplest programs you can deploy on Flow.\n//\n// The HelloWorld contract contains a single string field and a public getter function.\n//\n// Follow the \"Hello, World!\" tutorial to learn more: https://docs.onflow.org/docs/hello-world\n\npub contract HelloWorld {\n\n    // Declare a public field of type String.\n    //\n    // All fields must be initialized in the init() function.\n    pub let greeting: String\n\n    pub event Greet(x: String)\n\n    // The init() function is required if the contract contains any fields.\n    init() {\n        self.greeting = \"Hello, World!\"\n    }\n\n    // Public function that returns our friendly greeting!\n    pub fun hello(): String {\n        emit Greet(x: self.greeting)\n        return self.greeting\n    }\n}\n"
                },
                "keys": [
                    {
                        "index": 0,
                        "publicKey": "ee69a34c1a8c4fdc5d55bd1a78174ef1fd5f579243ecb032672cbb23845973d4b8c393078807b820dcf6a4573dbca61dcfffc2ceca1af3d2bc03eac31fdbe67c",
                        "signAlgo": 2,
                        "hashAlgo": 3,
                        "weight": 1000,
                        "sequenceNumber": 8,
                        "revoked": false
                    }
                ]
            }
        ],
        "events": [
            [
                {
                    "transactionId": "d6b543cd5ae4307c741a4ed87ce5077cd23075d633b3732ad843ccd29dd516bf",
                    "type": "A.f8d6e0586b0a20c7.HelloWorld.Greet",
                    "transactionIndex": 1,
                    "eventIndex": 0,
                    "data": {
                        "x": "Hello, World!"
                    }
                }
            ]
        ]
    },
    {
        "block": {
            "id": "671b0bfc468f3d563ff22395d5ac0a8d65782b97cbd805147641767fdc8357ec",
            "parentId": "300f74117e6af5d7f6ef247fab36532761f91cc1b1b1c298d094a2cb53ff1bf1",
            "height": 3,
            "timestamp": "2021-10-01T17:05:28.538Z",
            "collectionGuarantees": [
                {
                    "collectionId": "45a9b0e9f5af7103c3f312312a3ceb7bf3ea6b530b615bdc1cc6d47c695b2b71",
                    "signatures": [
                        ""
                    ]
                }
            ],
            "blockSeals": [],
            "signatures": [
                ""
            ]
        },
        "collections": [
            {
                "blockId": "671b0bfc468f3d563ff22395d5ac0a8d65782b97cbd805147641767fdc8357ec",
                "id": "45a9b0e9f5af7103c3f312312a3ceb7bf3ea6b530b615bdc1cc6d47c695b2b71",
                "transactionIds": [
                    "14b1dffacf909c7319a8ccb20bbc8f8531da18d4403b8098e1370cfe41971a52"
                ]
            }
        ],
        "transactions": [
            {
                "id": "14b1dffacf909c7319a8ccb20bbc8f8531da18d4403b8098e1370cfe41971a52",
                "script": "import HelloWorld from 0xf8d6e0586b0a20c7\n\ntransaction {\n\n  prepare(acct: AuthAccount) {}\n\n  execute {\n    log(HelloWorld.hello())\n  }\n}\n",
                "args": [],
                "referenceBlockId": "300f74117e6af5d7f6ef247fab36532761f91cc1b1b1c298d094a2cb53ff1bf1",
                "gasLimit": 1000,
                "proposalKey": {
                    "address": "f8d6e0586b0a20c7",
                    "keyId": 0,
                    "sequenceNumber": 2
                },
                "payer": "f8d6e0586b0a20c7",
                "authorizers": [
                    "f8d6e0586b0a20c7"
                ],
                "payloadSignatures": [],
                "envelopeSignatures": [
                    {
                        "address": "f8d6e0586b0a20c7",
                        "keyId": 0,
                        "signature": "505abfc9d4decc75a344e8002e006c4a7ec3ac24eedc46ea197a9c4e6d12b96d84b2e30af6458da599baa0c855de86fc1a4921593b8a55f7fa87bd4ce97eb58e"
                    }
                ],
                "status": {
                    "status": 4,
                    "statusCode": 0,
                    "errorMessage": "",
                    "eventsCount": 1
                }
            }
        ],
        "accounts": [
            {
                "address": "0xf8d6e0586b0a20c7",
                "balance": 999999999999400000,
                "code": "",
                "contracts": {
                    "FlowServiceAccount": "import FungibleToken from 0xee82856bf20e2aa6\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FlowFees from 0xe5a8b7f23e8b548f\nimport FlowStorageFees from 0xf8d6e0586b0a20c7\n\npub contract FlowServiceAccount {\n\n    pub event TransactionFeeUpdated(newFee: UFix64)\n\n    pub event AccountCreationFeeUpdated(newFee: UFix64)\n\n    pub event AccountCreatorAdded(accountCreator: Address)\n\n    pub event AccountCreatorRemoved(accountCreator: Address)\n\n    pub event IsAccountCreationRestrictedUpdated(isRestricted: Bool)\n\n    /// A fixed-rate fee charged to execute a transaction\n    pub var transactionFee: UFix64\n\n    /// A fixed-rate fee charged to create a new account\n    pub var accountCreationFee: UFix64\n\n    /// The list of account addresses that have permission to create accounts\n    access(contract) var accountCreators: {Address: Bool}\n\n    /// Initialize an account with a FlowToken Vault and publish capabilities.\n    pub fun initDefaultToken(_ acct: AuthAccount) {\n        // Create a new FlowToken Vault and save it in storage\n        acct.save(<-FlowToken.createEmptyVault(), to: /storage/flowTokenVault)\n\n        // Create a public capability to the Vault that only exposes\n        // the deposit function through the Receiver interface\n        acct.link<&FlowToken.Vault{FungibleToken.Receiver}>(\n            /public/flowTokenReceiver,\n            target: /storage/flowTokenVault\n        )\n\n        // Create a public capability to the Vault that only exposes\n        // the balance field through the Balance interface\n        acct.link<&FlowToken.Vault{FungibleToken.Balance}>(\n            /public/flowTokenBalance,\n            target: /storage/flowTokenVault\n        )\n    }\n\n    /// Get the default token balance on an account\n    pub fun defaultTokenBalance(_ acct: PublicAccount): UFix64 {\n        let balanceRef = acct\n            .getCapability(/public/flowTokenBalance)\n            .borrow<&FlowToken.Vault{FungibleToken.Balance}>()!\n\n        return balanceRef.balance\n    }\n\n    /// Return a reference to the default token vault on an account\n    pub fun defaultTokenVault(_ acct: AuthAccount): &FlowToken.Vault {\n        return acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Unable to borrow reference to the default token vault\")\n    }\n\n    /// Called when a transaction is submitted to deduct the fee\n    /// from the AuthAccount that submitted it\n    pub fun deductTransactionFee(_ acct: AuthAccount) {\n        if self.transactionFee == UFix64(0) {\n            return\n        }\n\n        let tokenVault = self.defaultTokenVault(acct)\n        let feeVault <- tokenVault.withdraw(amount: self.transactionFee)\n\n        FlowFees.deposit(from: <-feeVault)\n    }\n\n    /// - Deducts the account creation fee from a payer account.\n    /// - Inits the default token.\n    /// - Inits account storage capacity.\n    pub fun setupNewAccount(newAccount: AuthAccount, payer: AuthAccount) {\n        if !FlowServiceAccount.isAccountCreator(payer.address) {\n            panic(\"Account not authorized to create accounts\")\n        }\n\n\n        if self.accountCreationFee < FlowStorageFees.minimumStorageReservation {\n            panic(\"Account creation fees setup incorrectly\")\n        }\n\n        let tokenVault = self.defaultTokenVault(payer)\n        let feeVault <- tokenVault.withdraw(amount: self.accountCreationFee)\n        let storageFeeVault <- (feeVault.withdraw(amount: FlowStorageFees.minimumStorageReservation) as! @FlowToken.Vault)\n        FlowFees.deposit(from: <-feeVault)\n\n        FlowServiceAccount.initDefaultToken(newAccount)\n\n        let vaultRef = FlowServiceAccount.defaultTokenVault(newAccount)\n\n        vaultRef.deposit(from: <-storageFeeVault)\n    }\n\n    /// Returns true if the given address is permitted to create accounts, false otherwise\n    pub fun isAccountCreator(_ address: Address): Bool {\n        // If account creation is not restricted, then anyone can create an account\n        if !self.isAccountCreationRestricted() {\n            return true\n        }\n        return self.accountCreators[address] ?? false\n    }\n\n    /// Is true if new acconts can only be created by approved accounts `self.accountCreators`\n    pub fun isAccountCreationRestricted(): Bool {\n        return self.account.copy<Bool>(from: /storage/isAccountCreationRestricted) ?? false\n    }\n\n    // Authorization resource to change the fields of the contract\n    /// Returns all addresses permitted to create accounts\n    pub fun getAccountCreators(): [Address] {\n        return self.accountCreators.keys\n    }\n\n    /// Authorization resource to change the fields of the contract\n    pub resource Administrator {\n\n        /// Sets the transaction fee\n        pub fun setTransactionFee(_ newFee: UFix64) {\n            FlowServiceAccount.transactionFee = newFee\n            emit TransactionFeeUpdated(newFee: newFee)\n        }\n\n        /// Sets the account creation fee\n        pub fun setAccountCreationFee(_ newFee: UFix64) {\n            FlowServiceAccount.accountCreationFee = newFee\n            emit AccountCreationFeeUpdated(newFee: newFee)\n        }\n\n        /// Adds an account address as an authorized account creator\n        pub fun addAccountCreator(_ accountCreator: Address) {\n            FlowServiceAccount.accountCreators[accountCreator] = true\n            emit AccountCreatorAdded(accountCreator: accountCreator)\n        }\n\n        /// Removes an account address as an authorized account creator\n        pub fun removeAccountCreator(_ accountCreator: Address) {\n            FlowServiceAccount.accountCreators.remove(key: accountCreator)\n            emit AccountCreatorRemoved(accountCreator: accountCreator)\n        }\n\n         pub fun setIsAccountCreationRestricted(_ enabled: Bool) {\n            let path = /storage/isAccountCreationRestricted\n            let oldValue = FlowServiceAccount.account.load<Bool>(from: path)\n            FlowServiceAccount.account.save<Bool>(enabled, to: path)\n            if enabled != oldValue {\n                emit IsAccountCreationRestrictedUpdated(isRestricted: enabled)\n            }\n        }\n    }\n\n    init() {\n        self.transactionFee = 0.0\n        self.accountCreationFee = 0.0\n\n        self.accountCreators = {}\n\n        let admin <- create Administrator()\n        admin.addAccountCreator(self.account.address)\n\n        self.account.save(<-admin, to: /storage/flowServiceAdmin)\n    }\n}\n",
                    "FlowStorageFees": "/*\n * The FlowStorageFees smart contract\n *\n * An account's storage capacity determines up to how much storage on chain it can use. \n * A storage capacity is calculated by multiplying the amount of reserved flow with `StorageFee.storageMegaBytesPerReservedFLOW`\n * The minimum amount of flow tokens reserved for storage capacity is `FlowStorageFees.minimumStorageReservation` this is paid during account creation, by the creator.\n * \n * At the end of all transactions, any account that had any value changed in their storage \n * has their storage capacity checked against their storage used and their main flow token vault against the minimum reservation.\n * If any account fails this check the transaction wil fail.\n * \n * An account moving/deleting its `FlowToken.Vault` resource will result \n * in the transaction failing because the account will have no storage capacity.\n * \n */\n\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FlowToken from 0x0ae53cb6e3f42a79\n\npub contract FlowStorageFees {\n\n    // Emitted when the amount of storage capacity an account has per reserved Flow token changes\n    pub event StorageMegaBytesPerReservedFLOWChanged(_ storageMegaBytesPerReservedFLOW: UFix64)\n\n    // Emitted when the minimum amount of Flow tokens that an account needs to have reserved for storage capacity changes.\n    pub event MinimumStorageReservationChanged(_ minimumStorageReservation: UFix64)\n\n    // Defines how much storage capacity every account has per reserved Flow token.\n    // definition is written per unit of flow instead of the inverse, \n    // so there is no loss of precision calculating storage from flow, \n    // but there is loss of precision when calculating flow per storage.\n    pub var storageMegaBytesPerReservedFLOW: UFix64\n\n    // Defines the minimum amount of Flow tokens that every account needs to have reserved for storage capacity.\n    // If an account has less then this amount reserved by the end of any transaction it participated in, the transaction will fail.\n    pub var minimumStorageReservation: UFix64\n\n    // An administrator resource that can change the parameters of the FlowStorageFees smart contract.\n    pub resource Administrator {\n\n        // Changes the amount of storage capacity an account has per accounts' reserved storage FLOW.\n        pub fun setStorageMegaBytesPerReservedFLOW(_ storageMegaBytesPerReservedFLOW: UFix64) {\n            if FlowStorageFees.storageMegaBytesPerReservedFLOW == storageMegaBytesPerReservedFLOW {\n              return\n            }\n            FlowStorageFees.storageMegaBytesPerReservedFLOW = storageMegaBytesPerReservedFLOW\n            emit StorageMegaBytesPerReservedFLOWChanged(storageMegaBytesPerReservedFLOW)\n        }\n\n        // Changes the minimum amount of FLOW an account has to have reserved.\n        pub fun setMinimumStorageReservation(_ minimumStorageReservation: UFix64) {\n            if FlowStorageFees.minimumStorageReservation == minimumStorageReservation {\n              return\n            }\n            FlowStorageFees.minimumStorageReservation = minimumStorageReservation\n            emit MinimumStorageReservationChanged(minimumStorageReservation)\n        }\n\n        access(contract) init(){}\n    }\n\n    // Returns megabytes\n    pub fun calculateAccountCapacity(_ accountAddress: Address): UFix64 {\n        let balanceRef = getAccount(accountAddress)\n            .getCapability<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance)!\n            .borrow() ?? panic(\"Could not borrow FLOW balance capability\")\n\n        // get address token balance\n        if balanceRef.balance < self.minimumStorageReservation {\n            // if < then minimum return 0\n            return 0.0\n        } else {\n            // return balance multiplied with megabytes per flow \n            return balanceRef.balance * self.storageMegaBytesPerReservedFLOW\n        }\n    }\n\n    // Amount in Flow tokens\n    // Returns megabytes\n    pub fun flowToStorageCapacity(_ amount: UFix64): UFix64 {\n        return amount * FlowStorageFees.storageMegaBytesPerReservedFLOW\n    }\n\n    // Amount in megabytes\n    // Returns Flow tokens\n    pub fun storageCapacityToFlow(_ amount: UFix64): UFix64 {\n        if FlowStorageFees.storageMegaBytesPerReservedFLOW == 0.0 as UFix64 {\n            return 0.0 as UFix64\n        }\n        // possible loss of precision\n        // putting the result back into `flowToStorageCapacity` might not yield the same result\n        return amount / FlowStorageFees.storageMegaBytesPerReservedFLOW\n    }\n\n    // converts storage used from UInt64 Bytes to UFix64 Megabytes.\n    pub fun convertUInt64StorageBytesToUFix64Megabytes(_ storage: UInt64): UFix64 {\n        // safe convert UInt64 to UFix64 (without overflow)\n        let f = UFix64(storage % 100000000 as UInt64) * 0.00000001 as UFix64 + UFix64(storage / 100000000 as UInt64)\n        // decimal point correction. Megabytes to bytes have a conversion of 10^-6 while UFix64 minimum value is 10^-8\n        let storageMb = f * 100.0 as UFix64\n        return storageMb\n    }\n\n    // Gets \"available\" balance of an account\n    // The available balance is its default token balance minus what is reserved for storage.\n    pub fun defaultTokenAvailableBalance(_ accountAddress: Address): UFix64 {\n        //get balance of account\n        let acct = getAccount(accountAddress)\n        let balanceRef = acct\n            .getCapability(/public/flowTokenBalance)\n            .borrow<&FlowToken.Vault{FungibleToken.Balance}>()!\n        let balance = balanceRef.balance\n\n        // get how much should be reserved for storage\n        var reserved = self.storageCapacityToFlow(self.convertUInt64StorageBytesToUFix64Megabytes(acct.storageUsed))\n        // at least self.minimumStorageReservation should be reserved\n        if reserved < self.minimumStorageReservation {\n            reserved = self.minimumStorageReservation\n        }\n\n        // balance could be less that what the account needs to have reserved for storage. In that case return 0.\n        if reserved > balance {\n            return 0.0\n        }\n        \n        return balance - reserved\n    }\n\n    init() {\n        self.storageMegaBytesPerReservedFLOW = 1.0 // 1 Mb per 1 Flow token\n        self.minimumStorageReservation = 0.0 // or 0 kb of minimum storage reservation\n\n        let admin <- create Administrator()\n        self.account.save(<-admin, to: /storage/storageFeesAdmin)\n    }\n}",
                    "HelloWorld": "// HelloWorld.cdc\n//\n// Welcome to Cadence! This is one of the simplest programs you can deploy on Flow.\n//\n// The HelloWorld contract contains a single string field and a public getter function.\n//\n// Follow the \"Hello, World!\" tutorial to learn more: https://docs.onflow.org/docs/hello-world\n\npub contract HelloWorld {\n\n    // Declare a public field of type String.\n    //\n    // All fields must be initialized in the init() function.\n    pub let greeting: String\n\n    pub event Greet(x: String)\n\n    // The init() function is required if the contract contains any fields.\n    init() {\n        self.greeting = \"Hello, World!\"\n    }\n\n    // Public function that returns our friendly greeting!\n    pub fun hello(): String {\n        emit Greet(x: self.greeting)\n        return self.greeting\n    }\n}\n"
                },
                "keys": [
                    {
                        "index": 0,
                        "publicKey": "ee69a34c1a8c4fdc5d55bd1a78174ef1fd5f579243ecb032672cbb23845973d4b8c393078807b820dcf6a4573dbca61dcfffc2ceca1af3d2bc03eac31fdbe67c",
                        "signAlgo": 2,
                        "hashAlgo": 3,
                        "weight": 1000,
                        "sequenceNumber": 8,
                        "revoked": false
                    }
                ]
            }
        ],
        "events": [
            [
                {
                    "transactionId": "14b1dffacf909c7319a8ccb20bbc8f8531da18d4403b8098e1370cfe41971a52",
                    "type": "A.f8d6e0586b0a20c7.HelloWorld.Greet",
                    "transactionIndex": 1,
                    "eventIndex": 0,
                    "data": {
                        "x": "Hello, World!"
                    }
                }
            ]
        ]
    },
    {
        "block": {
            "id": "68219dfcc2b2197e41be5296819067067ac48432ee977b45f2ce56b85d729864",
            "parentId": "671b0bfc468f3d563ff22395d5ac0a8d65782b97cbd805147641767fdc8357ec",
            "height": 4,
            "timestamp": "2021-10-01T17:05:28.875Z",
            "collectionGuarantees": [
                {
                    "collectionId": "c9a23ead3b86c800554bded80f164d647a438ca5fa1251804f802f86e44dc7b1",
                    "signatures": [
                        ""
                    ]
                }
            ],
            "blockSeals": [],
            "signatures": [
                ""
            ]
        },
        "collections": [
            {
                "blockId": "68219dfcc2b2197e41be5296819067067ac48432ee977b45f2ce56b85d729864",
                "id": "c9a23ead3b86c800554bded80f164d647a438ca5fa1251804f802f86e44dc7b1",
                "transactionIds": [
                    "32e6b3e196cc9723b20abe57326240ab1034a144c21703d243deb0f7d47288c1"
                ]
            }
        ],
        "transactions": [
            {
                "id": "32e6b3e196cc9723b20abe57326240ab1034a144c21703d243deb0f7d47288c1",
                "script": "import HelloWorld from 0xf8d6e0586b0a20c7\n\ntransaction {\n\n  prepare(acct: AuthAccount) {}\n\n  execute {\n    log(HelloWorld.hello())\n  }\n}\n",
                "args": [],
                "referenceBlockId": "671b0bfc468f3d563ff22395d5ac0a8d65782b97cbd805147641767fdc8357ec",
                "gasLimit": 1000,
                "proposalKey": {
                    "address": "f8d6e0586b0a20c7",
                    "keyId": 0,
                    "sequenceNumber": 3
                },
                "payer": "f8d6e0586b0a20c7",
                "authorizers": [
                    "f8d6e0586b0a20c7"
                ],
                "payloadSignatures": [],
                "envelopeSignatures": [
                    {
                        "address": "f8d6e0586b0a20c7",
                        "keyId": 0,
                        "signature": "e39f232675175e60e5d9379b3fb908f24683457426fa382cf906e1f45cd803d41e74293898c0adfa1ab490d89bd72447f7fce5a8f467ab7125281cf6469a880c"
                    }
                ],
                "status": {
                    "status": 4,
                    "statusCode": 0,
                    "errorMessage": "",
                    "eventsCount": 1
                }
            }
        ],
        "accounts": [
            {
                "address": "0xf8d6e0586b0a20c7",
                "balance": 999999999999400000,
                "code": "",
                "contracts": {
                    "FlowServiceAccount": "import FungibleToken from 0xee82856bf20e2aa6\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FlowFees from 0xe5a8b7f23e8b548f\nimport FlowStorageFees from 0xf8d6e0586b0a20c7\n\npub contract FlowServiceAccount {\n\n    pub event TransactionFeeUpdated(newFee: UFix64)\n\n    pub event AccountCreationFeeUpdated(newFee: UFix64)\n\n    pub event AccountCreatorAdded(accountCreator: Address)\n\n    pub event AccountCreatorRemoved(accountCreator: Address)\n\n    pub event IsAccountCreationRestrictedUpdated(isRestricted: Bool)\n\n    /// A fixed-rate fee charged to execute a transaction\n    pub var transactionFee: UFix64\n\n    /// A fixed-rate fee charged to create a new account\n    pub var accountCreationFee: UFix64\n\n    /// The list of account addresses that have permission to create accounts\n    access(contract) var accountCreators: {Address: Bool}\n\n    /// Initialize an account with a FlowToken Vault and publish capabilities.\n    pub fun initDefaultToken(_ acct: AuthAccount) {\n        // Create a new FlowToken Vault and save it in storage\n        acct.save(<-FlowToken.createEmptyVault(), to: /storage/flowTokenVault)\n\n        // Create a public capability to the Vault that only exposes\n        // the deposit function through the Receiver interface\n        acct.link<&FlowToken.Vault{FungibleToken.Receiver}>(\n            /public/flowTokenReceiver,\n            target: /storage/flowTokenVault\n        )\n\n        // Create a public capability to the Vault that only exposes\n        // the balance field through the Balance interface\n        acct.link<&FlowToken.Vault{FungibleToken.Balance}>(\n            /public/flowTokenBalance,\n            target: /storage/flowTokenVault\n        )\n    }\n\n    /// Get the default token balance on an account\n    pub fun defaultTokenBalance(_ acct: PublicAccount): UFix64 {\n        let balanceRef = acct\n            .getCapability(/public/flowTokenBalance)\n            .borrow<&FlowToken.Vault{FungibleToken.Balance}>()!\n\n        return balanceRef.balance\n    }\n\n    /// Return a reference to the default token vault on an account\n    pub fun defaultTokenVault(_ acct: AuthAccount): &FlowToken.Vault {\n        return acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Unable to borrow reference to the default token vault\")\n    }\n\n    /// Called when a transaction is submitted to deduct the fee\n    /// from the AuthAccount that submitted it\n    pub fun deductTransactionFee(_ acct: AuthAccount) {\n        if self.transactionFee == UFix64(0) {\n            return\n        }\n\n        let tokenVault = self.defaultTokenVault(acct)\n        let feeVault <- tokenVault.withdraw(amount: self.transactionFee)\n\n        FlowFees.deposit(from: <-feeVault)\n    }\n\n    /// - Deducts the account creation fee from a payer account.\n    /// - Inits the default token.\n    /// - Inits account storage capacity.\n    pub fun setupNewAccount(newAccount: AuthAccount, payer: AuthAccount) {\n        if !FlowServiceAccount.isAccountCreator(payer.address) {\n            panic(\"Account not authorized to create accounts\")\n        }\n\n\n        if self.accountCreationFee < FlowStorageFees.minimumStorageReservation {\n            panic(\"Account creation fees setup incorrectly\")\n        }\n\n        let tokenVault = self.defaultTokenVault(payer)\n        let feeVault <- tokenVault.withdraw(amount: self.accountCreationFee)\n        let storageFeeVault <- (feeVault.withdraw(amount: FlowStorageFees.minimumStorageReservation) as! @FlowToken.Vault)\n        FlowFees.deposit(from: <-feeVault)\n\n        FlowServiceAccount.initDefaultToken(newAccount)\n\n        let vaultRef = FlowServiceAccount.defaultTokenVault(newAccount)\n\n        vaultRef.deposit(from: <-storageFeeVault)\n    }\n\n    /// Returns true if the given address is permitted to create accounts, false otherwise\n    pub fun isAccountCreator(_ address: Address): Bool {\n        // If account creation is not restricted, then anyone can create an account\n        if !self.isAccountCreationRestricted() {\n            return true\n        }\n        return self.accountCreators[address] ?? false\n    }\n\n    /// Is true if new acconts can only be created by approved accounts `self.accountCreators`\n    pub fun isAccountCreationRestricted(): Bool {\n        return self.account.copy<Bool>(from: /storage/isAccountCreationRestricted) ?? false\n    }\n\n    // Authorization resource to change the fields of the contract\n    /// Returns all addresses permitted to create accounts\n    pub fun getAccountCreators(): [Address] {\n        return self.accountCreators.keys\n    }\n\n    /// Authorization resource to change the fields of the contract\n    pub resource Administrator {\n\n        /// Sets the transaction fee\n        pub fun setTransactionFee(_ newFee: UFix64) {\n            FlowServiceAccount.transactionFee = newFee\n            emit TransactionFeeUpdated(newFee: newFee)\n        }\n\n        /// Sets the account creation fee\n        pub fun setAccountCreationFee(_ newFee: UFix64) {\n            FlowServiceAccount.accountCreationFee = newFee\n            emit AccountCreationFeeUpdated(newFee: newFee)\n        }\n\n        /// Adds an account address as an authorized account creator\n        pub fun addAccountCreator(_ accountCreator: Address) {\n            FlowServiceAccount.accountCreators[accountCreator] = true\n            emit AccountCreatorAdded(accountCreator: accountCreator)\n        }\n\n        /// Removes an account address as an authorized account creator\n        pub fun removeAccountCreator(_ accountCreator: Address) {\n            FlowServiceAccount.accountCreators.remove(key: accountCreator)\n            emit AccountCreatorRemoved(accountCreator: accountCreator)\n        }\n\n         pub fun setIsAccountCreationRestricted(_ enabled: Bool) {\n            let path = /storage/isAccountCreationRestricted\n            let oldValue = FlowServiceAccount.account.load<Bool>(from: path)\n            FlowServiceAccount.account.save<Bool>(enabled, to: path)\n            if enabled != oldValue {\n                emit IsAccountCreationRestrictedUpdated(isRestricted: enabled)\n            }\n        }\n    }\n\n    init() {\n        self.transactionFee = 0.0\n        self.accountCreationFee = 0.0\n\n        self.accountCreators = {}\n\n        let admin <- create Administrator()\n        admin.addAccountCreator(self.account.address)\n\n        self.account.save(<-admin, to: /storage/flowServiceAdmin)\n    }\n}\n",
                    "FlowStorageFees": "/*\n * The FlowStorageFees smart contract\n *\n * An account's storage capacity determines up to how much storage on chain it can use. \n * A storage capacity is calculated by multiplying the amount of reserved flow with `StorageFee.storageMegaBytesPerReservedFLOW`\n * The minimum amount of flow tokens reserved for storage capacity is `FlowStorageFees.minimumStorageReservation` this is paid during account creation, by the creator.\n * \n * At the end of all transactions, any account that had any value changed in their storage \n * has their storage capacity checked against their storage used and their main flow token vault against the minimum reservation.\n * If any account fails this check the transaction wil fail.\n * \n * An account moving/deleting its `FlowToken.Vault` resource will result \n * in the transaction failing because the account will have no storage capacity.\n * \n */\n\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FlowToken from 0x0ae53cb6e3f42a79\n\npub contract FlowStorageFees {\n\n    // Emitted when the amount of storage capacity an account has per reserved Flow token changes\n    pub event StorageMegaBytesPerReservedFLOWChanged(_ storageMegaBytesPerReservedFLOW: UFix64)\n\n    // Emitted when the minimum amount of Flow tokens that an account needs to have reserved for storage capacity changes.\n    pub event MinimumStorageReservationChanged(_ minimumStorageReservation: UFix64)\n\n    // Defines how much storage capacity every account has per reserved Flow token.\n    // definition is written per unit of flow instead of the inverse, \n    // so there is no loss of precision calculating storage from flow, \n    // but there is loss of precision when calculating flow per storage.\n    pub var storageMegaBytesPerReservedFLOW: UFix64\n\n    // Defines the minimum amount of Flow tokens that every account needs to have reserved for storage capacity.\n    // If an account has less then this amount reserved by the end of any transaction it participated in, the transaction will fail.\n    pub var minimumStorageReservation: UFix64\n\n    // An administrator resource that can change the parameters of the FlowStorageFees smart contract.\n    pub resource Administrator {\n\n        // Changes the amount of storage capacity an account has per accounts' reserved storage FLOW.\n        pub fun setStorageMegaBytesPerReservedFLOW(_ storageMegaBytesPerReservedFLOW: UFix64) {\n            if FlowStorageFees.storageMegaBytesPerReservedFLOW == storageMegaBytesPerReservedFLOW {\n              return\n            }\n            FlowStorageFees.storageMegaBytesPerReservedFLOW = storageMegaBytesPerReservedFLOW\n            emit StorageMegaBytesPerReservedFLOWChanged(storageMegaBytesPerReservedFLOW)\n        }\n\n        // Changes the minimum amount of FLOW an account has to have reserved.\n        pub fun setMinimumStorageReservation(_ minimumStorageReservation: UFix64) {\n            if FlowStorageFees.minimumStorageReservation == minimumStorageReservation {\n              return\n            }\n            FlowStorageFees.minimumStorageReservation = minimumStorageReservation\n            emit MinimumStorageReservationChanged(minimumStorageReservation)\n        }\n\n        access(contract) init(){}\n    }\n\n    // Returns megabytes\n    pub fun calculateAccountCapacity(_ accountAddress: Address): UFix64 {\n        let balanceRef = getAccount(accountAddress)\n            .getCapability<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance)!\n            .borrow() ?? panic(\"Could not borrow FLOW balance capability\")\n\n        // get address token balance\n        if balanceRef.balance < self.minimumStorageReservation {\n            // if < then minimum return 0\n            return 0.0\n        } else {\n            // return balance multiplied with megabytes per flow \n            return balanceRef.balance * self.storageMegaBytesPerReservedFLOW\n        }\n    }\n\n    // Amount in Flow tokens\n    // Returns megabytes\n    pub fun flowToStorageCapacity(_ amount: UFix64): UFix64 {\n        return amount * FlowStorageFees.storageMegaBytesPerReservedFLOW\n    }\n\n    // Amount in megabytes\n    // Returns Flow tokens\n    pub fun storageCapacityToFlow(_ amount: UFix64): UFix64 {\n        if FlowStorageFees.storageMegaBytesPerReservedFLOW == 0.0 as UFix64 {\n            return 0.0 as UFix64\n        }\n        // possible loss of precision\n        // putting the result back into `flowToStorageCapacity` might not yield the same result\n        return amount / FlowStorageFees.storageMegaBytesPerReservedFLOW\n    }\n\n    // converts storage used from UInt64 Bytes to UFix64 Megabytes.\n    pub fun convertUInt64StorageBytesToUFix64Megabytes(_ storage: UInt64): UFix64 {\n        // safe convert UInt64 to UFix64 (without overflow)\n        let f = UFix64(storage % 100000000 as UInt64) * 0.00000001 as UFix64 + UFix64(storage / 100000000 as UInt64)\n        // decimal point correction. Megabytes to bytes have a conversion of 10^-6 while UFix64 minimum value is 10^-8\n        let storageMb = f * 100.0 as UFix64\n        return storageMb\n    }\n\n    // Gets \"available\" balance of an account\n    // The available balance is its default token balance minus what is reserved for storage.\n    pub fun defaultTokenAvailableBalance(_ accountAddress: Address): UFix64 {\n        //get balance of account\n        let acct = getAccount(accountAddress)\n        let balanceRef = acct\n            .getCapability(/public/flowTokenBalance)\n            .borrow<&FlowToken.Vault{FungibleToken.Balance}>()!\n        let balance = balanceRef.balance\n\n        // get how much should be reserved for storage\n        var reserved = self.storageCapacityToFlow(self.convertUInt64StorageBytesToUFix64Megabytes(acct.storageUsed))\n        // at least self.minimumStorageReservation should be reserved\n        if reserved < self.minimumStorageReservation {\n            reserved = self.minimumStorageReservation\n        }\n\n        // balance could be less that what the account needs to have reserved for storage. In that case return 0.\n        if reserved > balance {\n            return 0.0\n        }\n        \n        return balance - reserved\n    }\n\n    init() {\n        self.storageMegaBytesPerReservedFLOW = 1.0 // 1 Mb per 1 Flow token\n        self.minimumStorageReservation = 0.0 // or 0 kb of minimum storage reservation\n\n        let admin <- create Administrator()\n        self.account.save(<-admin, to: /storage/storageFeesAdmin)\n    }\n}",
                    "HelloWorld": "// HelloWorld.cdc\n//\n// Welcome to Cadence! This is one of the simplest programs you can deploy on Flow.\n//\n// The HelloWorld contract contains a single string field and a public getter function.\n//\n// Follow the \"Hello, World!\" tutorial to learn more: https://docs.onflow.org/docs/hello-world\n\npub contract HelloWorld {\n\n    // Declare a public field of type String.\n    //\n    // All fields must be initialized in the init() function.\n    pub let greeting: String\n\n    pub event Greet(x: String)\n\n    // The init() function is required if the contract contains any fields.\n    init() {\n        self.greeting = \"Hello, World!\"\n    }\n\n    // Public function that returns our friendly greeting!\n    pub fun hello(): String {\n        emit Greet(x: self.greeting)\n        return self.greeting\n    }\n}\n"
                },
                "keys": [
                    {
                        "index": 0,
                        "publicKey": "ee69a34c1a8c4fdc5d55bd1a78174ef1fd5f579243ecb032672cbb23845973d4b8c393078807b820dcf6a4573dbca61dcfffc2ceca1af3d2bc03eac31fdbe67c",
                        "signAlgo": 2,
                        "hashAlgo": 3,
                        "weight": 1000,
                        "sequenceNumber": 8,
                        "revoked": false
                    }
                ]
            }
        ],
        "events": [
            [
                {
                    "transactionId": "32e6b3e196cc9723b20abe57326240ab1034a144c21703d243deb0f7d47288c1",
                    "type": "A.f8d6e0586b0a20c7.HelloWorld.Greet",
                    "transactionIndex": 1,
                    "eventIndex": 0,
                    "data": {
                        "x": "Hello, World!"
                    }
                }
            ]
        ]
    },
    {
        "block": {
            "id": "f1b06f14dd9862302f842fe9f42df9a105f103386fcfe5cd7f56243a531dd468",
            "parentId": "68219dfcc2b2197e41be5296819067067ac48432ee977b45f2ce56b85d729864",
            "height": 5,
            "timestamp": "2021-10-01T17:05:29.243Z",
            "collectionGuarantees": [
                {
                    "collectionId": "fa8a404292e06088a8cc7c1d5c924eeb55e25f6458d9b0dce79ef55e64351ad6",
                    "signatures": [
                        ""
                    ]
                }
            ],
            "blockSeals": [],
            "signatures": [
                ""
            ]
        },
        "collections": [
            {
                "blockId": "f1b06f14dd9862302f842fe9f42df9a105f103386fcfe5cd7f56243a531dd468",
                "id": "fa8a404292e06088a8cc7c1d5c924eeb55e25f6458d9b0dce79ef55e64351ad6",
                "transactionIds": [
                    "5cd42fa1e6667e0dc7e04d988086f71fea2b40caf5877122ecdc8dc6db498427"
                ]
            }
        ],
        "transactions": [
            {
                "id": "5cd42fa1e6667e0dc7e04d988086f71fea2b40caf5877122ecdc8dc6db498427",
                "script": "import HelloWorld from 0xf8d6e0586b0a20c7\n\ntransaction {\n\n  prepare(acct: AuthAccount) {}\n\n  execute {\n    log(HelloWorld.hello())\n  }\n}\n",
                "args": [],
                "referenceBlockId": "68219dfcc2b2197e41be5296819067067ac48432ee977b45f2ce56b85d729864",
                "gasLimit": 1000,
                "proposalKey": {
                    "address": "f8d6e0586b0a20c7",
                    "keyId": 0,
                    "sequenceNumber": 4
                },
                "payer": "f8d6e0586b0a20c7",
                "authorizers": [
                    "f8d6e0586b0a20c7"
                ],
                "payloadSignatures": [],
                "envelopeSignatures": [
                    {
                        "address": "f8d6e0586b0a20c7",
                        "keyId": 0,
                        "signature": "a5bd9c96e695059a14417b1fa36751b256ad7843be5a3d02961dcb7c74dcf510b24b0c99118f17c4cefda938a91d75d0fc60e6eea025251f90dd9d651fb1469c"
                    }
                ],
                "status": {
                    "status": 4,
                    "statusCode": 0,
                    "errorMessage": "",
                    "eventsCount": 1
                }
            }
        ],
        "accounts": [
            {
                "address": "0xf8d6e0586b0a20c7",
                "balance": 999999999999400000,
                "code": "",
                "contracts": {
                    "FlowServiceAccount": "import FungibleToken from 0xee82856bf20e2aa6\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FlowFees from 0xe5a8b7f23e8b548f\nimport FlowStorageFees from 0xf8d6e0586b0a20c7\n\npub contract FlowServiceAccount {\n\n    pub event TransactionFeeUpdated(newFee: UFix64)\n\n    pub event AccountCreationFeeUpdated(newFee: UFix64)\n\n    pub event AccountCreatorAdded(accountCreator: Address)\n\n    pub event AccountCreatorRemoved(accountCreator: Address)\n\n    pub event IsAccountCreationRestrictedUpdated(isRestricted: Bool)\n\n    /// A fixed-rate fee charged to execute a transaction\n    pub var transactionFee: UFix64\n\n    /// A fixed-rate fee charged to create a new account\n    pub var accountCreationFee: UFix64\n\n    /// The list of account addresses that have permission to create accounts\n    access(contract) var accountCreators: {Address: Bool}\n\n    /// Initialize an account with a FlowToken Vault and publish capabilities.\n    pub fun initDefaultToken(_ acct: AuthAccount) {\n        // Create a new FlowToken Vault and save it in storage\n        acct.save(<-FlowToken.createEmptyVault(), to: /storage/flowTokenVault)\n\n        // Create a public capability to the Vault that only exposes\n        // the deposit function through the Receiver interface\n        acct.link<&FlowToken.Vault{FungibleToken.Receiver}>(\n            /public/flowTokenReceiver,\n            target: /storage/flowTokenVault\n        )\n\n        // Create a public capability to the Vault that only exposes\n        // the balance field through the Balance interface\n        acct.link<&FlowToken.Vault{FungibleToken.Balance}>(\n            /public/flowTokenBalance,\n            target: /storage/flowTokenVault\n        )\n    }\n\n    /// Get the default token balance on an account\n    pub fun defaultTokenBalance(_ acct: PublicAccount): UFix64 {\n        let balanceRef = acct\n            .getCapability(/public/flowTokenBalance)\n            .borrow<&FlowToken.Vault{FungibleToken.Balance}>()!\n\n        return balanceRef.balance\n    }\n\n    /// Return a reference to the default token vault on an account\n    pub fun defaultTokenVault(_ acct: AuthAccount): &FlowToken.Vault {\n        return acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Unable to borrow reference to the default token vault\")\n    }\n\n    /// Called when a transaction is submitted to deduct the fee\n    /// from the AuthAccount that submitted it\n    pub fun deductTransactionFee(_ acct: AuthAccount) {\n        if self.transactionFee == UFix64(0) {\n            return\n        }\n\n        let tokenVault = self.defaultTokenVault(acct)\n        let feeVault <- tokenVault.withdraw(amount: self.transactionFee)\n\n        FlowFees.deposit(from: <-feeVault)\n    }\n\n    /// - Deducts the account creation fee from a payer account.\n    /// - Inits the default token.\n    /// - Inits account storage capacity.\n    pub fun setupNewAccount(newAccount: AuthAccount, payer: AuthAccount) {\n        if !FlowServiceAccount.isAccountCreator(payer.address) {\n            panic(\"Account not authorized to create accounts\")\n        }\n\n\n        if self.accountCreationFee < FlowStorageFees.minimumStorageReservation {\n            panic(\"Account creation fees setup incorrectly\")\n        }\n\n        let tokenVault = self.defaultTokenVault(payer)\n        let feeVault <- tokenVault.withdraw(amount: self.accountCreationFee)\n        let storageFeeVault <- (feeVault.withdraw(amount: FlowStorageFees.minimumStorageReservation) as! @FlowToken.Vault)\n        FlowFees.deposit(from: <-feeVault)\n\n        FlowServiceAccount.initDefaultToken(newAccount)\n\n        let vaultRef = FlowServiceAccount.defaultTokenVault(newAccount)\n\n        vaultRef.deposit(from: <-storageFeeVault)\n    }\n\n    /// Returns true if the given address is permitted to create accounts, false otherwise\n    pub fun isAccountCreator(_ address: Address): Bool {\n        // If account creation is not restricted, then anyone can create an account\n        if !self.isAccountCreationRestricted() {\n            return true\n        }\n        return self.accountCreators[address] ?? false\n    }\n\n    /// Is true if new acconts can only be created by approved accounts `self.accountCreators`\n    pub fun isAccountCreationRestricted(): Bool {\n        return self.account.copy<Bool>(from: /storage/isAccountCreationRestricted) ?? false\n    }\n\n    // Authorization resource to change the fields of the contract\n    /// Returns all addresses permitted to create accounts\n    pub fun getAccountCreators(): [Address] {\n        return self.accountCreators.keys\n    }\n\n    /// Authorization resource to change the fields of the contract\n    pub resource Administrator {\n\n        /// Sets the transaction fee\n        pub fun setTransactionFee(_ newFee: UFix64) {\n            FlowServiceAccount.transactionFee = newFee\n            emit TransactionFeeUpdated(newFee: newFee)\n        }\n\n        /// Sets the account creation fee\n        pub fun setAccountCreationFee(_ newFee: UFix64) {\n            FlowServiceAccount.accountCreationFee = newFee\n            emit AccountCreationFeeUpdated(newFee: newFee)\n        }\n\n        /// Adds an account address as an authorized account creator\n        pub fun addAccountCreator(_ accountCreator: Address) {\n            FlowServiceAccount.accountCreators[accountCreator] = true\n            emit AccountCreatorAdded(accountCreator: accountCreator)\n        }\n\n        /// Removes an account address as an authorized account creator\n        pub fun removeAccountCreator(_ accountCreator: Address) {\n            FlowServiceAccount.accountCreators.remove(key: accountCreator)\n            emit AccountCreatorRemoved(accountCreator: accountCreator)\n        }\n\n         pub fun setIsAccountCreationRestricted(_ enabled: Bool) {\n            let path = /storage/isAccountCreationRestricted\n            let oldValue = FlowServiceAccount.account.load<Bool>(from: path)\n            FlowServiceAccount.account.save<Bool>(enabled, to: path)\n            if enabled != oldValue {\n                emit IsAccountCreationRestrictedUpdated(isRestricted: enabled)\n            }\n        }\n    }\n\n    init() {\n        self.transactionFee = 0.0\n        self.accountCreationFee = 0.0\n\n        self.accountCreators = {}\n\n        let admin <- create Administrator()\n        admin.addAccountCreator(self.account.address)\n\n        self.account.save(<-admin, to: /storage/flowServiceAdmin)\n    }\n}\n",
                    "FlowStorageFees": "/*\n * The FlowStorageFees smart contract\n *\n * An account's storage capacity determines up to how much storage on chain it can use. \n * A storage capacity is calculated by multiplying the amount of reserved flow with `StorageFee.storageMegaBytesPerReservedFLOW`\n * The minimum amount of flow tokens reserved for storage capacity is `FlowStorageFees.minimumStorageReservation` this is paid during account creation, by the creator.\n * \n * At the end of all transactions, any account that had any value changed in their storage \n * has their storage capacity checked against their storage used and their main flow token vault against the minimum reservation.\n * If any account fails this check the transaction wil fail.\n * \n * An account moving/deleting its `FlowToken.Vault` resource will result \n * in the transaction failing because the account will have no storage capacity.\n * \n */\n\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FlowToken from 0x0ae53cb6e3f42a79\n\npub contract FlowStorageFees {\n\n    // Emitted when the amount of storage capacity an account has per reserved Flow token changes\n    pub event StorageMegaBytesPerReservedFLOWChanged(_ storageMegaBytesPerReservedFLOW: UFix64)\n\n    // Emitted when the minimum amount of Flow tokens that an account needs to have reserved for storage capacity changes.\n    pub event MinimumStorageReservationChanged(_ minimumStorageReservation: UFix64)\n\n    // Defines how much storage capacity every account has per reserved Flow token.\n    // definition is written per unit of flow instead of the inverse, \n    // so there is no loss of precision calculating storage from flow, \n    // but there is loss of precision when calculating flow per storage.\n    pub var storageMegaBytesPerReservedFLOW: UFix64\n\n    // Defines the minimum amount of Flow tokens that every account needs to have reserved for storage capacity.\n    // If an account has less then this amount reserved by the end of any transaction it participated in, the transaction will fail.\n    pub var minimumStorageReservation: UFix64\n\n    // An administrator resource that can change the parameters of the FlowStorageFees smart contract.\n    pub resource Administrator {\n\n        // Changes the amount of storage capacity an account has per accounts' reserved storage FLOW.\n        pub fun setStorageMegaBytesPerReservedFLOW(_ storageMegaBytesPerReservedFLOW: UFix64) {\n            if FlowStorageFees.storageMegaBytesPerReservedFLOW == storageMegaBytesPerReservedFLOW {\n              return\n            }\n            FlowStorageFees.storageMegaBytesPerReservedFLOW = storageMegaBytesPerReservedFLOW\n            emit StorageMegaBytesPerReservedFLOWChanged(storageMegaBytesPerReservedFLOW)\n        }\n\n        // Changes the minimum amount of FLOW an account has to have reserved.\n        pub fun setMinimumStorageReservation(_ minimumStorageReservation: UFix64) {\n            if FlowStorageFees.minimumStorageReservation == minimumStorageReservation {\n              return\n            }\n            FlowStorageFees.minimumStorageReservation = minimumStorageReservation\n            emit MinimumStorageReservationChanged(minimumStorageReservation)\n        }\n\n        access(contract) init(){}\n    }\n\n    // Returns megabytes\n    pub fun calculateAccountCapacity(_ accountAddress: Address): UFix64 {\n        let balanceRef = getAccount(accountAddress)\n            .getCapability<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance)!\n            .borrow() ?? panic(\"Could not borrow FLOW balance capability\")\n\n        // get address token balance\n        if balanceRef.balance < self.minimumStorageReservation {\n            // if < then minimum return 0\n            return 0.0\n        } else {\n            // return balance multiplied with megabytes per flow \n            return balanceRef.balance * self.storageMegaBytesPerReservedFLOW\n        }\n    }\n\n    // Amount in Flow tokens\n    // Returns megabytes\n    pub fun flowToStorageCapacity(_ amount: UFix64): UFix64 {\n        return amount * FlowStorageFees.storageMegaBytesPerReservedFLOW\n    }\n\n    // Amount in megabytes\n    // Returns Flow tokens\n    pub fun storageCapacityToFlow(_ amount: UFix64): UFix64 {\n        if FlowStorageFees.storageMegaBytesPerReservedFLOW == 0.0 as UFix64 {\n            return 0.0 as UFix64\n        }\n        // possible loss of precision\n        // putting the result back into `flowToStorageCapacity` might not yield the same result\n        return amount / FlowStorageFees.storageMegaBytesPerReservedFLOW\n    }\n\n    // converts storage used from UInt64 Bytes to UFix64 Megabytes.\n    pub fun convertUInt64StorageBytesToUFix64Megabytes(_ storage: UInt64): UFix64 {\n        // safe convert UInt64 to UFix64 (without overflow)\n        let f = UFix64(storage % 100000000 as UInt64) * 0.00000001 as UFix64 + UFix64(storage / 100000000 as UInt64)\n        // decimal point correction. Megabytes to bytes have a conversion of 10^-6 while UFix64 minimum value is 10^-8\n        let storageMb = f * 100.0 as UFix64\n        return storageMb\n    }\n\n    // Gets \"available\" balance of an account\n    // The available balance is its default token balance minus what is reserved for storage.\n    pub fun defaultTokenAvailableBalance(_ accountAddress: Address): UFix64 {\n        //get balance of account\n        let acct = getAccount(accountAddress)\n        let balanceRef = acct\n            .getCapability(/public/flowTokenBalance)\n            .borrow<&FlowToken.Vault{FungibleToken.Balance}>()!\n        let balance = balanceRef.balance\n\n        // get how much should be reserved for storage\n        var reserved = self.storageCapacityToFlow(self.convertUInt64StorageBytesToUFix64Megabytes(acct.storageUsed))\n        // at least self.minimumStorageReservation should be reserved\n        if reserved < self.minimumStorageReservation {\n            reserved = self.minimumStorageReservation\n        }\n\n        // balance could be less that what the account needs to have reserved for storage. In that case return 0.\n        if reserved > balance {\n            return 0.0\n        }\n        \n        return balance - reserved\n    }\n\n    init() {\n        self.storageMegaBytesPerReservedFLOW = 1.0 // 1 Mb per 1 Flow token\n        self.minimumStorageReservation = 0.0 // or 0 kb of minimum storage reservation\n\n        let admin <- create Administrator()\n        self.account.save(<-admin, to: /storage/storageFeesAdmin)\n    }\n}",
                    "HelloWorld": "// HelloWorld.cdc\n//\n// Welcome to Cadence! This is one of the simplest programs you can deploy on Flow.\n//\n// The HelloWorld contract contains a single string field and a public getter function.\n//\n// Follow the \"Hello, World!\" tutorial to learn more: https://docs.onflow.org/docs/hello-world\n\npub contract HelloWorld {\n\n    // Declare a public field of type String.\n    //\n    // All fields must be initialized in the init() function.\n    pub let greeting: String\n\n    pub event Greet(x: String)\n\n    // The init() function is required if the contract contains any fields.\n    init() {\n        self.greeting = \"Hello, World!\"\n    }\n\n    // Public function that returns our friendly greeting!\n    pub fun hello(): String {\n        emit Greet(x: self.greeting)\n        return self.greeting\n    }\n}\n"
                },
                "keys": [
                    {
                        "index": 0,
                        "publicKey": "ee69a34c1a8c4fdc5d55bd1a78174ef1fd5f579243ecb032672cbb23845973d4b8c393078807b820dcf6a4573dbca61dcfffc2ceca1af3d2bc03eac31fdbe67c",
                        "signAlgo": 2,
                        "hashAlgo": 3,
                        "weight": 1000,
                        "sequenceNumber": 8,
                        "revoked": false
                    }
                ]
            }
        ],
        "events": [
            [
                {
                    "transactionId": "5cd42fa1e6667e0dc7e04d988086f71fea2b40caf5877122ecdc8dc6db498427",
                    "type": "A.f8d6e0586b0a20c7.HelloWorld.Greet",
                    "transactionIndex": 1,
                    "eventIndex": 0,
                    "data": {
                        "x": "Hello, World!"
                    }
                }
            ]
        ]
    },
    {
        "block": {
            "id": "3c191022d9eb39ba3fb746e5c0ed27916c5f4e6d2a07e7c0e4806a0662159c73",
            "parentId": "f1b06f14dd9862302f842fe9f42df9a105f103386fcfe5cd7f56243a531dd468",
            "height": 6,
            "timestamp": "2021-10-01T17:05:29.578Z",
            "collectionGuarantees": [
                {
                    "collectionId": "29cc470c46ee54a39afddaf614211681cf497aa72cc2cb7c646195dcecbdcaf5",
                    "signatures": [
                        ""
                    ]
                }
            ],
            "blockSeals": [],
            "signatures": [
                ""
            ]
        },
        "collections": [
            {
                "blockId": "3c191022d9eb39ba3fb746e5c0ed27916c5f4e6d2a07e7c0e4806a0662159c73",
                "id": "29cc470c46ee54a39afddaf614211681cf497aa72cc2cb7c646195dcecbdcaf5",
                "transactionIds": [
                    "f243986bb624b8f72241f8f832265fa5d5e67d4568fca0bfdc129d16163c41d5"
                ]
            }
        ],
        "transactions": [
            {
                "id": "f243986bb624b8f72241f8f832265fa5d5e67d4568fca0bfdc129d16163c41d5",
                "script": "\n\ttransaction(name: String, code: String ) {\n\t\tprepare(signer: AuthAccount) {\n\t\t\tsigner.contracts.add(name: name, code: code.decodeHex() )\n\t\t}\n\t}",
                "args": [
                    {
                        "type": "String",
                        "value": "HelloWorld"
                    },
                    {
                        "type": "String",
                        "value": "2f2f2048656c6c6f576f726c642e6364630a2f2f0a2f2f2057656c636f6d6520746f20436164656e6365212054686973206973206f6e65206f66207468652073696d706c6573742070726f6772616d7320796f752063616e206465706c6f79206f6e20466c6f772e0a2f2f0a2f2f205468652048656c6c6f576f726c6420636f6e747261637420636f6e7461696e7320612073696e676c6520737472696e67206669656c6420616e642061207075626c6963206765747465722066756e6374696f6e2e0a2f2f0a2f2f20466f6c6c6f7720746865202248656c6c6f2c20576f726c642122207475746f7269616c20746f206c6561726e206d6f72653a2068747470733a2f2f646f63732e6f6e666c6f772e6f72672f646f63732f68656c6c6f2d776f726c640a0a70756220636f6e74726163742048656c6c6f576f726c64207b0a0a202020202f2f204465636c6172652061207075626c6963206669656c64206f66207479706520537472696e672e0a202020202f2f0a202020202f2f20416c6c206669656c6473206d75737420626520696e697469616c697a656420696e2074686520696e697428292066756e6374696f6e2e0a20202020707562206c6574206772656574696e673a20537472696e670a0a202020202f2f2054686520696e697428292066756e6374696f6e2069732072657175697265642069662074686520636f6e747261637420636f6e7461696e7320616e79206669656c64732e0a20202020696e69742829207b0a202020202020202073656c662e6772656574696e67203d202248656c6c6f2c20576f726c6421220a202020207d0a0a7d0a"
                    }
                ],
                "referenceBlockId": "f1b06f14dd9862302f842fe9f42df9a105f103386fcfe5cd7f56243a531dd468",
                "gasLimit": 9999,
                "proposalKey": {
                    "address": "f8d6e0586b0a20c7",
                    "keyId": 0,
                    "sequenceNumber": 5
                },
                "payer": "f8d6e0586b0a20c7",
                "authorizers": [
                    "f8d6e0586b0a20c7"
                ],
                "payloadSignatures": [],
                "envelopeSignatures": [
                    {
                        "address": "f8d6e0586b0a20c7",
                        "keyId": 0,
                        "signature": "588e113d1ebd32c3b75888a9e0ffe2586582892c1e38af4d8e17eaab05be74e30a3a31a4e4126f74cd8f5276fd9a219d728a84ad5e60a11649c8b0831e9f4709"
                    }
                ],
                "status": {
                    "status": 4,
                    "statusCode": 1,
                    "errorMessage": "execution error code 1101: [Error Code: 1101] cadence runtime error Execution failed:\nerror: cannot overwrite existing contract with name \"HelloWorld\" in account 0xf8d6e0586b0a20c7\n --> f243986bb624b8f72241f8f832265fa5d5e67d4568fca0bfdc129d16163c41d5:4:3\n  |\n4 | \t\t\tsigner.contracts.add(name: name, code: code.decodeHex() )\n  |    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n",
                    "eventsCount": 0
                }
            }
        ],
        "accounts": [
            {
                "address": "0xf8d6e0586b0a20c7",
                "balance": 999999999999400000,
                "code": "",
                "contracts": {
                    "FlowServiceAccount": "import FungibleToken from 0xee82856bf20e2aa6\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FlowFees from 0xe5a8b7f23e8b548f\nimport FlowStorageFees from 0xf8d6e0586b0a20c7\n\npub contract FlowServiceAccount {\n\n    pub event TransactionFeeUpdated(newFee: UFix64)\n\n    pub event AccountCreationFeeUpdated(newFee: UFix64)\n\n    pub event AccountCreatorAdded(accountCreator: Address)\n\n    pub event AccountCreatorRemoved(accountCreator: Address)\n\n    pub event IsAccountCreationRestrictedUpdated(isRestricted: Bool)\n\n    /// A fixed-rate fee charged to execute a transaction\n    pub var transactionFee: UFix64\n\n    /// A fixed-rate fee charged to create a new account\n    pub var accountCreationFee: UFix64\n\n    /// The list of account addresses that have permission to create accounts\n    access(contract) var accountCreators: {Address: Bool}\n\n    /// Initialize an account with a FlowToken Vault and publish capabilities.\n    pub fun initDefaultToken(_ acct: AuthAccount) {\n        // Create a new FlowToken Vault and save it in storage\n        acct.save(<-FlowToken.createEmptyVault(), to: /storage/flowTokenVault)\n\n        // Create a public capability to the Vault that only exposes\n        // the deposit function through the Receiver interface\n        acct.link<&FlowToken.Vault{FungibleToken.Receiver}>(\n            /public/flowTokenReceiver,\n            target: /storage/flowTokenVault\n        )\n\n        // Create a public capability to the Vault that only exposes\n        // the balance field through the Balance interface\n        acct.link<&FlowToken.Vault{FungibleToken.Balance}>(\n            /public/flowTokenBalance,\n            target: /storage/flowTokenVault\n        )\n    }\n\n    /// Get the default token balance on an account\n    pub fun defaultTokenBalance(_ acct: PublicAccount): UFix64 {\n        let balanceRef = acct\n            .getCapability(/public/flowTokenBalance)\n            .borrow<&FlowToken.Vault{FungibleToken.Balance}>()!\n\n        return balanceRef.balance\n    }\n\n    /// Return a reference to the default token vault on an account\n    pub fun defaultTokenVault(_ acct: AuthAccount): &FlowToken.Vault {\n        return acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Unable to borrow reference to the default token vault\")\n    }\n\n    /// Called when a transaction is submitted to deduct the fee\n    /// from the AuthAccount that submitted it\n    pub fun deductTransactionFee(_ acct: AuthAccount) {\n        if self.transactionFee == UFix64(0) {\n            return\n        }\n\n        let tokenVault = self.defaultTokenVault(acct)\n        let feeVault <- tokenVault.withdraw(amount: self.transactionFee)\n\n        FlowFees.deposit(from: <-feeVault)\n    }\n\n    /// - Deducts the account creation fee from a payer account.\n    /// - Inits the default token.\n    /// - Inits account storage capacity.\n    pub fun setupNewAccount(newAccount: AuthAccount, payer: AuthAccount) {\n        if !FlowServiceAccount.isAccountCreator(payer.address) {\n            panic(\"Account not authorized to create accounts\")\n        }\n\n\n        if self.accountCreationFee < FlowStorageFees.minimumStorageReservation {\n            panic(\"Account creation fees setup incorrectly\")\n        }\n\n        let tokenVault = self.defaultTokenVault(payer)\n        let feeVault <- tokenVault.withdraw(amount: self.accountCreationFee)\n        let storageFeeVault <- (feeVault.withdraw(amount: FlowStorageFees.minimumStorageReservation) as! @FlowToken.Vault)\n        FlowFees.deposit(from: <-feeVault)\n\n        FlowServiceAccount.initDefaultToken(newAccount)\n\n        let vaultRef = FlowServiceAccount.defaultTokenVault(newAccount)\n\n        vaultRef.deposit(from: <-storageFeeVault)\n    }\n\n    /// Returns true if the given address is permitted to create accounts, false otherwise\n    pub fun isAccountCreator(_ address: Address): Bool {\n        // If account creation is not restricted, then anyone can create an account\n        if !self.isAccountCreationRestricted() {\n            return true\n        }\n        return self.accountCreators[address] ?? false\n    }\n\n    /// Is true if new acconts can only be created by approved accounts `self.accountCreators`\n    pub fun isAccountCreationRestricted(): Bool {\n        return self.account.copy<Bool>(from: /storage/isAccountCreationRestricted) ?? false\n    }\n\n    // Authorization resource to change the fields of the contract\n    /// Returns all addresses permitted to create accounts\n    pub fun getAccountCreators(): [Address] {\n        return self.accountCreators.keys\n    }\n\n    /// Authorization resource to change the fields of the contract\n    pub resource Administrator {\n\n        /// Sets the transaction fee\n        pub fun setTransactionFee(_ newFee: UFix64) {\n            FlowServiceAccount.transactionFee = newFee\n            emit TransactionFeeUpdated(newFee: newFee)\n        }\n\n        /// Sets the account creation fee\n        pub fun setAccountCreationFee(_ newFee: UFix64) {\n            FlowServiceAccount.accountCreationFee = newFee\n            emit AccountCreationFeeUpdated(newFee: newFee)\n        }\n\n        /// Adds an account address as an authorized account creator\n        pub fun addAccountCreator(_ accountCreator: Address) {\n            FlowServiceAccount.accountCreators[accountCreator] = true\n            emit AccountCreatorAdded(accountCreator: accountCreator)\n        }\n\n        /// Removes an account address as an authorized account creator\n        pub fun removeAccountCreator(_ accountCreator: Address) {\n            FlowServiceAccount.accountCreators.remove(key: accountCreator)\n            emit AccountCreatorRemoved(accountCreator: accountCreator)\n        }\n\n         pub fun setIsAccountCreationRestricted(_ enabled: Bool) {\n            let path = /storage/isAccountCreationRestricted\n            let oldValue = FlowServiceAccount.account.load<Bool>(from: path)\n            FlowServiceAccount.account.save<Bool>(enabled, to: path)\n            if enabled != oldValue {\n                emit IsAccountCreationRestrictedUpdated(isRestricted: enabled)\n            }\n        }\n    }\n\n    init() {\n        self.transactionFee = 0.0\n        self.accountCreationFee = 0.0\n\n        self.accountCreators = {}\n\n        let admin <- create Administrator()\n        admin.addAccountCreator(self.account.address)\n\n        self.account.save(<-admin, to: /storage/flowServiceAdmin)\n    }\n}\n",
                    "FlowStorageFees": "/*\n * The FlowStorageFees smart contract\n *\n * An account's storage capacity determines up to how much storage on chain it can use. \n * A storage capacity is calculated by multiplying the amount of reserved flow with `StorageFee.storageMegaBytesPerReservedFLOW`\n * The minimum amount of flow tokens reserved for storage capacity is `FlowStorageFees.minimumStorageReservation` this is paid during account creation, by the creator.\n * \n * At the end of all transactions, any account that had any value changed in their storage \n * has their storage capacity checked against their storage used and their main flow token vault against the minimum reservation.\n * If any account fails this check the transaction wil fail.\n * \n * An account moving/deleting its `FlowToken.Vault` resource will result \n * in the transaction failing because the account will have no storage capacity.\n * \n */\n\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FlowToken from 0x0ae53cb6e3f42a79\n\npub contract FlowStorageFees {\n\n    // Emitted when the amount of storage capacity an account has per reserved Flow token changes\n    pub event StorageMegaBytesPerReservedFLOWChanged(_ storageMegaBytesPerReservedFLOW: UFix64)\n\n    // Emitted when the minimum amount of Flow tokens that an account needs to have reserved for storage capacity changes.\n    pub event MinimumStorageReservationChanged(_ minimumStorageReservation: UFix64)\n\n    // Defines how much storage capacity every account has per reserved Flow token.\n    // definition is written per unit of flow instead of the inverse, \n    // so there is no loss of precision calculating storage from flow, \n    // but there is loss of precision when calculating flow per storage.\n    pub var storageMegaBytesPerReservedFLOW: UFix64\n\n    // Defines the minimum amount of Flow tokens that every account needs to have reserved for storage capacity.\n    // If an account has less then this amount reserved by the end of any transaction it participated in, the transaction will fail.\n    pub var minimumStorageReservation: UFix64\n\n    // An administrator resource that can change the parameters of the FlowStorageFees smart contract.\n    pub resource Administrator {\n\n        // Changes the amount of storage capacity an account has per accounts' reserved storage FLOW.\n        pub fun setStorageMegaBytesPerReservedFLOW(_ storageMegaBytesPerReservedFLOW: UFix64) {\n            if FlowStorageFees.storageMegaBytesPerReservedFLOW == storageMegaBytesPerReservedFLOW {\n              return\n            }\n            FlowStorageFees.storageMegaBytesPerReservedFLOW = storageMegaBytesPerReservedFLOW\n            emit StorageMegaBytesPerReservedFLOWChanged(storageMegaBytesPerReservedFLOW)\n        }\n\n        // Changes the minimum amount of FLOW an account has to have reserved.\n        pub fun setMinimumStorageReservation(_ minimumStorageReservation: UFix64) {\n            if FlowStorageFees.minimumStorageReservation == minimumStorageReservation {\n              return\n            }\n            FlowStorageFees.minimumStorageReservation = minimumStorageReservation\n            emit MinimumStorageReservationChanged(minimumStorageReservation)\n        }\n\n        access(contract) init(){}\n    }\n\n    // Returns megabytes\n    pub fun calculateAccountCapacity(_ accountAddress: Address): UFix64 {\n        let balanceRef = getAccount(accountAddress)\n            .getCapability<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance)!\n            .borrow() ?? panic(\"Could not borrow FLOW balance capability\")\n\n        // get address token balance\n        if balanceRef.balance < self.minimumStorageReservation {\n            // if < then minimum return 0\n            return 0.0\n        } else {\n            // return balance multiplied with megabytes per flow \n            return balanceRef.balance * self.storageMegaBytesPerReservedFLOW\n        }\n    }\n\n    // Amount in Flow tokens\n    // Returns megabytes\n    pub fun flowToStorageCapacity(_ amount: UFix64): UFix64 {\n        return amount * FlowStorageFees.storageMegaBytesPerReservedFLOW\n    }\n\n    // Amount in megabytes\n    // Returns Flow tokens\n    pub fun storageCapacityToFlow(_ amount: UFix64): UFix64 {\n        if FlowStorageFees.storageMegaBytesPerReservedFLOW == 0.0 as UFix64 {\n            return 0.0 as UFix64\n        }\n        // possible loss of precision\n        // putting the result back into `flowToStorageCapacity` might not yield the same result\n        return amount / FlowStorageFees.storageMegaBytesPerReservedFLOW\n    }\n\n    // converts storage used from UInt64 Bytes to UFix64 Megabytes.\n    pub fun convertUInt64StorageBytesToUFix64Megabytes(_ storage: UInt64): UFix64 {\n        // safe convert UInt64 to UFix64 (without overflow)\n        let f = UFix64(storage % 100000000 as UInt64) * 0.00000001 as UFix64 + UFix64(storage / 100000000 as UInt64)\n        // decimal point correction. Megabytes to bytes have a conversion of 10^-6 while UFix64 minimum value is 10^-8\n        let storageMb = f * 100.0 as UFix64\n        return storageMb\n    }\n\n    // Gets \"available\" balance of an account\n    // The available balance is its default token balance minus what is reserved for storage.\n    pub fun defaultTokenAvailableBalance(_ accountAddress: Address): UFix64 {\n        //get balance of account\n        let acct = getAccount(accountAddress)\n        let balanceRef = acct\n            .getCapability(/public/flowTokenBalance)\n            .borrow<&FlowToken.Vault{FungibleToken.Balance}>()!\n        let balance = balanceRef.balance\n\n        // get how much should be reserved for storage\n        var reserved = self.storageCapacityToFlow(self.convertUInt64StorageBytesToUFix64Megabytes(acct.storageUsed))\n        // at least self.minimumStorageReservation should be reserved\n        if reserved < self.minimumStorageReservation {\n            reserved = self.minimumStorageReservation\n        }\n\n        // balance could be less that what the account needs to have reserved for storage. In that case return 0.\n        if reserved > balance {\n            return 0.0\n        }\n        \n        return balance - reserved\n    }\n\n    init() {\n        self.storageMegaBytesPerReservedFLOW = 1.0 // 1 Mb per 1 Flow token\n        self.minimumStorageReservation = 0.0 // or 0 kb of minimum storage reservation\n\n        let admin <- create Administrator()\n        self.account.save(<-admin, to: /storage/storageFeesAdmin)\n    }\n}",
                    "HelloWorld": "// HelloWorld.cdc\n//\n// Welcome to Cadence! This is one of the simplest programs you can deploy on Flow.\n//\n// The HelloWorld contract contains a single string field and a public getter function.\n//\n// Follow the \"Hello, World!\" tutorial to learn more: https://docs.onflow.org/docs/hello-world\n\npub contract HelloWorld {\n\n    // Declare a public field of type String.\n    //\n    // All fields must be initialized in the init() function.\n    pub let greeting: String\n\n    pub event Greet(x: String)\n\n    // The init() function is required if the contract contains any fields.\n    init() {\n        self.greeting = \"Hello, World!\"\n    }\n\n    // Public function that returns our friendly greeting!\n    pub fun hello(): String {\n        emit Greet(x: self.greeting)\n        return self.greeting\n    }\n}\n"
                },
                "keys": [
                    {
                        "index": 0,
                        "publicKey": "ee69a34c1a8c4fdc5d55bd1a78174ef1fd5f579243ecb032672cbb23845973d4b8c393078807b820dcf6a4573dbca61dcfffc2ceca1af3d2bc03eac31fdbe67c",
                        "signAlgo": 2,
                        "hashAlgo": 3,
                        "weight": 1000,
                        "sequenceNumber": 8,
                        "revoked": false
                    }
                ]
            }
        ],
        "events": [
            []
        ]
    },
    {
        "block": {
            "id": "a654320e34708197bb572ab523573942dcc35ff70ad7d2b44a5ae76c886d1c7f",
            "parentId": "3c191022d9eb39ba3fb746e5c0ed27916c5f4e6d2a07e7c0e4806a0662159c73",
            "height": 7,
            "timestamp": "2021-10-02T17:46:23.758Z",
            "collectionGuarantees": [
                {
                    "collectionId": "f1bf8265179d2d1abf42f7852abb54fe46f44ecc0dfb6b83c4aa8fcd68d46103",
                    "signatures": [
                        ""
                    ]
                }
            ],
            "blockSeals": [],
            "signatures": [
                ""
            ]
        },
        "collections": [
            {
                "blockId": "a654320e34708197bb572ab523573942dcc35ff70ad7d2b44a5ae76c886d1c7f",
                "id": "f1bf8265179d2d1abf42f7852abb54fe46f44ecc0dfb6b83c4aa8fcd68d46103",
                "transactionIds": [
                    "c2669509fdf50d22f42404b74dedc0eec9ebdd81ca3770bfe6ea19bd2e49eaff"
                ]
            }
        ],
        "transactions": [
            {
                "id": "c2669509fdf50d22f42404b74dedc0eec9ebdd81ca3770bfe6ea19bd2e49eaff",
                "script": "\ntransaction(publicKeys: [String], contracts: {String: String}) {\n\tprepare(signer: AuthAccount) {\n\t\tlet acct = AuthAccount(payer: signer)\n\n\t\tfor key in publicKeys {\n\t\t\tacct.addPublicKey(key.decodeHex())\n\t\t}\n\n\t\tfor contract in contracts.keys {\n\t\t\tacct.contracts.add(name: contract, code: contracts[contract]!.decodeHex())\n\t\t}\n\t}\n}\n",
                "args": [
                    {
                        "type": "Array",
                        "value": []
                    },
                    {
                        "type": "Dictionary",
                        "value": []
                    }
                ],
                "referenceBlockId": "3c191022d9eb39ba3fb746e5c0ed27916c5f4e6d2a07e7c0e4806a0662159c73",
                "gasLimit": 9999,
                "proposalKey": {
                    "address": "f8d6e0586b0a20c7",
                    "keyId": 0,
                    "sequenceNumber": 5
                },
                "payer": "f8d6e0586b0a20c7",
                "authorizers": [
                    "f8d6e0586b0a20c7"
                ],
                "payloadSignatures": [],
                "envelopeSignatures": [
                    {
                        "address": "f8d6e0586b0a20c7",
                        "keyId": 0,
                        "signature": "bed24c990d91cad44ea6714acfd482cf8e40c5f4f6e9dc58208d4a7359a41216bb89bf82275ff9f73b6d46fe21ecedbd31e41b20cfdf3f95295cbd22bb80e2d6"
                    }
                ],
                "status": {
                    "status": 4,
                    "statusCode": 0,
                    "errorMessage": "",
                    "eventsCount": 6
                }
            }
        ],
        "accounts": [
            {
                "address": "0xf8d6e0586b0a20c7",
                "balance": 999999999999400000,
                "code": "",
                "contracts": {
                    "FlowServiceAccount": "import FungibleToken from 0xee82856bf20e2aa6\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FlowFees from 0xe5a8b7f23e8b548f\nimport FlowStorageFees from 0xf8d6e0586b0a20c7\n\npub contract FlowServiceAccount {\n\n    pub event TransactionFeeUpdated(newFee: UFix64)\n\n    pub event AccountCreationFeeUpdated(newFee: UFix64)\n\n    pub event AccountCreatorAdded(accountCreator: Address)\n\n    pub event AccountCreatorRemoved(accountCreator: Address)\n\n    pub event IsAccountCreationRestrictedUpdated(isRestricted: Bool)\n\n    /// A fixed-rate fee charged to execute a transaction\n    pub var transactionFee: UFix64\n\n    /// A fixed-rate fee charged to create a new account\n    pub var accountCreationFee: UFix64\n\n    /// The list of account addresses that have permission to create accounts\n    access(contract) var accountCreators: {Address: Bool}\n\n    /// Initialize an account with a FlowToken Vault and publish capabilities.\n    pub fun initDefaultToken(_ acct: AuthAccount) {\n        // Create a new FlowToken Vault and save it in storage\n        acct.save(<-FlowToken.createEmptyVault(), to: /storage/flowTokenVault)\n\n        // Create a public capability to the Vault that only exposes\n        // the deposit function through the Receiver interface\n        acct.link<&FlowToken.Vault{FungibleToken.Receiver}>(\n            /public/flowTokenReceiver,\n            target: /storage/flowTokenVault\n        )\n\n        // Create a public capability to the Vault that only exposes\n        // the balance field through the Balance interface\n        acct.link<&FlowToken.Vault{FungibleToken.Balance}>(\n            /public/flowTokenBalance,\n            target: /storage/flowTokenVault\n        )\n    }\n\n    /// Get the default token balance on an account\n    pub fun defaultTokenBalance(_ acct: PublicAccount): UFix64 {\n        let balanceRef = acct\n            .getCapability(/public/flowTokenBalance)\n            .borrow<&FlowToken.Vault{FungibleToken.Balance}>()!\n\n        return balanceRef.balance\n    }\n\n    /// Return a reference to the default token vault on an account\n    pub fun defaultTokenVault(_ acct: AuthAccount): &FlowToken.Vault {\n        return acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Unable to borrow reference to the default token vault\")\n    }\n\n    /// Called when a transaction is submitted to deduct the fee\n    /// from the AuthAccount that submitted it\n    pub fun deductTransactionFee(_ acct: AuthAccount) {\n        if self.transactionFee == UFix64(0) {\n            return\n        }\n\n        let tokenVault = self.defaultTokenVault(acct)\n        let feeVault <- tokenVault.withdraw(amount: self.transactionFee)\n\n        FlowFees.deposit(from: <-feeVault)\n    }\n\n    /// - Deducts the account creation fee from a payer account.\n    /// - Inits the default token.\n    /// - Inits account storage capacity.\n    pub fun setupNewAccount(newAccount: AuthAccount, payer: AuthAccount) {\n        if !FlowServiceAccount.isAccountCreator(payer.address) {\n            panic(\"Account not authorized to create accounts\")\n        }\n\n\n        if self.accountCreationFee < FlowStorageFees.minimumStorageReservation {\n            panic(\"Account creation fees setup incorrectly\")\n        }\n\n        let tokenVault = self.defaultTokenVault(payer)\n        let feeVault <- tokenVault.withdraw(amount: self.accountCreationFee)\n        let storageFeeVault <- (feeVault.withdraw(amount: FlowStorageFees.minimumStorageReservation) as! @FlowToken.Vault)\n        FlowFees.deposit(from: <-feeVault)\n\n        FlowServiceAccount.initDefaultToken(newAccount)\n\n        let vaultRef = FlowServiceAccount.defaultTokenVault(newAccount)\n\n        vaultRef.deposit(from: <-storageFeeVault)\n    }\n\n    /// Returns true if the given address is permitted to create accounts, false otherwise\n    pub fun isAccountCreator(_ address: Address): Bool {\n        // If account creation is not restricted, then anyone can create an account\n        if !self.isAccountCreationRestricted() {\n            return true\n        }\n        return self.accountCreators[address] ?? false\n    }\n\n    /// Is true if new acconts can only be created by approved accounts `self.accountCreators`\n    pub fun isAccountCreationRestricted(): Bool {\n        return self.account.copy<Bool>(from: /storage/isAccountCreationRestricted) ?? false\n    }\n\n    // Authorization resource to change the fields of the contract\n    /// Returns all addresses permitted to create accounts\n    pub fun getAccountCreators(): [Address] {\n        return self.accountCreators.keys\n    }\n\n    /// Authorization resource to change the fields of the contract\n    pub resource Administrator {\n\n        /// Sets the transaction fee\n        pub fun setTransactionFee(_ newFee: UFix64) {\n            FlowServiceAccount.transactionFee = newFee\n            emit TransactionFeeUpdated(newFee: newFee)\n        }\n\n        /// Sets the account creation fee\n        pub fun setAccountCreationFee(_ newFee: UFix64) {\n            FlowServiceAccount.accountCreationFee = newFee\n            emit AccountCreationFeeUpdated(newFee: newFee)\n        }\n\n        /// Adds an account address as an authorized account creator\n        pub fun addAccountCreator(_ accountCreator: Address) {\n            FlowServiceAccount.accountCreators[accountCreator] = true\n            emit AccountCreatorAdded(accountCreator: accountCreator)\n        }\n\n        /// Removes an account address as an authorized account creator\n        pub fun removeAccountCreator(_ accountCreator: Address) {\n            FlowServiceAccount.accountCreators.remove(key: accountCreator)\n            emit AccountCreatorRemoved(accountCreator: accountCreator)\n        }\n\n         pub fun setIsAccountCreationRestricted(_ enabled: Bool) {\n            let path = /storage/isAccountCreationRestricted\n            let oldValue = FlowServiceAccount.account.load<Bool>(from: path)\n            FlowServiceAccount.account.save<Bool>(enabled, to: path)\n            if enabled != oldValue {\n                emit IsAccountCreationRestrictedUpdated(isRestricted: enabled)\n            }\n        }\n    }\n\n    init() {\n        self.transactionFee = 0.0\n        self.accountCreationFee = 0.0\n\n        self.accountCreators = {}\n\n        let admin <- create Administrator()\n        admin.addAccountCreator(self.account.address)\n\n        self.account.save(<-admin, to: /storage/flowServiceAdmin)\n    }\n}\n",
                    "FlowStorageFees": "/*\n * The FlowStorageFees smart contract\n *\n * An account's storage capacity determines up to how much storage on chain it can use. \n * A storage capacity is calculated by multiplying the amount of reserved flow with `StorageFee.storageMegaBytesPerReservedFLOW`\n * The minimum amount of flow tokens reserved for storage capacity is `FlowStorageFees.minimumStorageReservation` this is paid during account creation, by the creator.\n * \n * At the end of all transactions, any account that had any value changed in their storage \n * has their storage capacity checked against their storage used and their main flow token vault against the minimum reservation.\n * If any account fails this check the transaction wil fail.\n * \n * An account moving/deleting its `FlowToken.Vault` resource will result \n * in the transaction failing because the account will have no storage capacity.\n * \n */\n\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FlowToken from 0x0ae53cb6e3f42a79\n\npub contract FlowStorageFees {\n\n    // Emitted when the amount of storage capacity an account has per reserved Flow token changes\n    pub event StorageMegaBytesPerReservedFLOWChanged(_ storageMegaBytesPerReservedFLOW: UFix64)\n\n    // Emitted when the minimum amount of Flow tokens that an account needs to have reserved for storage capacity changes.\n    pub event MinimumStorageReservationChanged(_ minimumStorageReservation: UFix64)\n\n    // Defines how much storage capacity every account has per reserved Flow token.\n    // definition is written per unit of flow instead of the inverse, \n    // so there is no loss of precision calculating storage from flow, \n    // but there is loss of precision when calculating flow per storage.\n    pub var storageMegaBytesPerReservedFLOW: UFix64\n\n    // Defines the minimum amount of Flow tokens that every account needs to have reserved for storage capacity.\n    // If an account has less then this amount reserved by the end of any transaction it participated in, the transaction will fail.\n    pub var minimumStorageReservation: UFix64\n\n    // An administrator resource that can change the parameters of the FlowStorageFees smart contract.\n    pub resource Administrator {\n\n        // Changes the amount of storage capacity an account has per accounts' reserved storage FLOW.\n        pub fun setStorageMegaBytesPerReservedFLOW(_ storageMegaBytesPerReservedFLOW: UFix64) {\n            if FlowStorageFees.storageMegaBytesPerReservedFLOW == storageMegaBytesPerReservedFLOW {\n              return\n            }\n            FlowStorageFees.storageMegaBytesPerReservedFLOW = storageMegaBytesPerReservedFLOW\n            emit StorageMegaBytesPerReservedFLOWChanged(storageMegaBytesPerReservedFLOW)\n        }\n\n        // Changes the minimum amount of FLOW an account has to have reserved.\n        pub fun setMinimumStorageReservation(_ minimumStorageReservation: UFix64) {\n            if FlowStorageFees.minimumStorageReservation == minimumStorageReservation {\n              return\n            }\n            FlowStorageFees.minimumStorageReservation = minimumStorageReservation\n            emit MinimumStorageReservationChanged(minimumStorageReservation)\n        }\n\n        access(contract) init(){}\n    }\n\n    // Returns megabytes\n    pub fun calculateAccountCapacity(_ accountAddress: Address): UFix64 {\n        let balanceRef = getAccount(accountAddress)\n            .getCapability<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance)!\n            .borrow() ?? panic(\"Could not borrow FLOW balance capability\")\n\n        // get address token balance\n        if balanceRef.balance < self.minimumStorageReservation {\n            // if < then minimum return 0\n            return 0.0\n        } else {\n            // return balance multiplied with megabytes per flow \n            return balanceRef.balance * self.storageMegaBytesPerReservedFLOW\n        }\n    }\n\n    // Amount in Flow tokens\n    // Returns megabytes\n    pub fun flowToStorageCapacity(_ amount: UFix64): UFix64 {\n        return amount * FlowStorageFees.storageMegaBytesPerReservedFLOW\n    }\n\n    // Amount in megabytes\n    // Returns Flow tokens\n    pub fun storageCapacityToFlow(_ amount: UFix64): UFix64 {\n        if FlowStorageFees.storageMegaBytesPerReservedFLOW == 0.0 as UFix64 {\n            return 0.0 as UFix64\n        }\n        // possible loss of precision\n        // putting the result back into `flowToStorageCapacity` might not yield the same result\n        return amount / FlowStorageFees.storageMegaBytesPerReservedFLOW\n    }\n\n    // converts storage used from UInt64 Bytes to UFix64 Megabytes.\n    pub fun convertUInt64StorageBytesToUFix64Megabytes(_ storage: UInt64): UFix64 {\n        // safe convert UInt64 to UFix64 (without overflow)\n        let f = UFix64(storage % 100000000 as UInt64) * 0.00000001 as UFix64 + UFix64(storage / 100000000 as UInt64)\n        // decimal point correction. Megabytes to bytes have a conversion of 10^-6 while UFix64 minimum value is 10^-8\n        let storageMb = f * 100.0 as UFix64\n        return storageMb\n    }\n\n    // Gets \"available\" balance of an account\n    // The available balance is its default token balance minus what is reserved for storage.\n    pub fun defaultTokenAvailableBalance(_ accountAddress: Address): UFix64 {\n        //get balance of account\n        let acct = getAccount(accountAddress)\n        let balanceRef = acct\n            .getCapability(/public/flowTokenBalance)\n            .borrow<&FlowToken.Vault{FungibleToken.Balance}>()!\n        let balance = balanceRef.balance\n\n        // get how much should be reserved for storage\n        var reserved = self.storageCapacityToFlow(self.convertUInt64StorageBytesToUFix64Megabytes(acct.storageUsed))\n        // at least self.minimumStorageReservation should be reserved\n        if reserved < self.minimumStorageReservation {\n            reserved = self.minimumStorageReservation\n        }\n\n        // balance could be less that what the account needs to have reserved for storage. In that case return 0.\n        if reserved > balance {\n            return 0.0\n        }\n        \n        return balance - reserved\n    }\n\n    init() {\n        self.storageMegaBytesPerReservedFLOW = 1.0 // 1 Mb per 1 Flow token\n        self.minimumStorageReservation = 0.0 // or 0 kb of minimum storage reservation\n\n        let admin <- create Administrator()\n        self.account.save(<-admin, to: /storage/storageFeesAdmin)\n    }\n}",
                    "HelloWorld": "// HelloWorld.cdc\n//\n// Welcome to Cadence! This is one of the simplest programs you can deploy on Flow.\n//\n// The HelloWorld contract contains a single string field and a public getter function.\n//\n// Follow the \"Hello, World!\" tutorial to learn more: https://docs.onflow.org/docs/hello-world\n\npub contract HelloWorld {\n\n    // Declare a public field of type String.\n    //\n    // All fields must be initialized in the init() function.\n    pub let greeting: String\n\n    pub event Greet(x: String)\n\n    // The init() function is required if the contract contains any fields.\n    init() {\n        self.greeting = \"Hello, World!\"\n    }\n\n    // Public function that returns our friendly greeting!\n    pub fun hello(): String {\n        emit Greet(x: self.greeting)\n        return self.greeting\n    }\n}\n"
                },
                "keys": [
                    {
                        "index": 0,
                        "publicKey": "ee69a34c1a8c4fdc5d55bd1a78174ef1fd5f579243ecb032672cbb23845973d4b8c393078807b820dcf6a4573dbca61dcfffc2ceca1af3d2bc03eac31fdbe67c",
                        "signAlgo": 2,
                        "hashAlgo": 3,
                        "weight": 1000,
                        "sequenceNumber": 8,
                        "revoked": false
                    }
                ]
            }
        ],
        "events": [
            [
                {
                    "transactionId": "c2669509fdf50d22f42404b74dedc0eec9ebdd81ca3770bfe6ea19bd2e49eaff",
                    "type": "A.0ae53cb6e3f42a79.FlowToken.TokensWithdrawn",
                    "transactionIndex": 1,
                    "eventIndex": 0,
                    "data": {
                        "amount": "0.00100000",
                        "from": "0xf8d6e0586b0a20c7"
                    }
                },
                {
                    "transactionId": "c2669509fdf50d22f42404b74dedc0eec9ebdd81ca3770bfe6ea19bd2e49eaff",
                    "type": "A.0ae53cb6e3f42a79.FlowToken.TokensWithdrawn",
                    "transactionIndex": 1,
                    "eventIndex": 1,
                    "data": {
                        "amount": "0.00100000",
                        "from": null
                    }
                },
                {
                    "transactionId": "c2669509fdf50d22f42404b74dedc0eec9ebdd81ca3770bfe6ea19bd2e49eaff",
                    "type": "A.0ae53cb6e3f42a79.FlowToken.TokensDeposited",
                    "transactionIndex": 1,
                    "eventIndex": 2,
                    "data": {
                        "amount": "0.00000000",
                        "to": "0xe5a8b7f23e8b548f"
                    }
                },
                {
                    "transactionId": "c2669509fdf50d22f42404b74dedc0eec9ebdd81ca3770bfe6ea19bd2e49eaff",
                    "type": "A.e5a8b7f23e8b548f.FlowFees.TokensDeposited",
                    "transactionIndex": 1,
                    "eventIndex": 3,
                    "data": {
                        "amount": "0.00000000"
                    }
                },
                {
                    "transactionId": "c2669509fdf50d22f42404b74dedc0eec9ebdd81ca3770bfe6ea19bd2e49eaff",
                    "type": "A.0ae53cb6e3f42a79.FlowToken.TokensDeposited",
                    "transactionIndex": 1,
                    "eventIndex": 4,
                    "data": {
                        "amount": "0.00100000",
                        "to": "0x01cf0e2f2f715450"
                    }
                },
                {
                    "transactionId": "c2669509fdf50d22f42404b74dedc0eec9ebdd81ca3770bfe6ea19bd2e49eaff",
                    "type": "flow.AccountCreated",
                    "transactionIndex": 1,
                    "eventIndex": 5,
                    "data": {
                        "address": "0x01cf0e2f2f715450"
                    }
                }
            ]
        ]
    },
    {
        "block": {
            "id": "47858e7fd972adbd918c3bbca7adbfb28a7b078437cb958eda5f719b56a98326",
            "parentId": "a654320e34708197bb572ab523573942dcc35ff70ad7d2b44a5ae76c886d1c7f",
            "height": 8,
            "timestamp": "2021-10-03T09:15:33.890Z",
            "collectionGuarantees": [
                {
                    "collectionId": "05d7d65a31df681a2f31dfaa99f0e0e1602f61fd3134dbed758171bb3ad429da",
                    "signatures": [
                        ""
                    ]
                }
            ],
            "blockSeals": [],
            "signatures": [
                ""
            ]
        },
        "collections": [
            {
                "blockId": "47858e7fd972adbd918c3bbca7adbfb28a7b078437cb958eda5f719b56a98326",
                "id": "05d7d65a31df681a2f31dfaa99f0e0e1602f61fd3134dbed758171bb3ad429da",
                "transactionIds": [
                    "e598ff0fbc5160f1781490db76b25884d435e477a9bbfa1c0733bd045b136c74"
                ]
            }
        ],
        "transactions": [
            {
                "id": "e598ff0fbc5160f1781490db76b25884d435e477a9bbfa1c0733bd045b136c74",
                "script": "\ntransaction(publicKeys: [String], contracts: {String: String}) {\n\tprepare(signer: AuthAccount) {\n\t\tlet acct = AuthAccount(payer: signer)\n\n\t\tfor key in publicKeys {\n\t\t\tacct.addPublicKey(key.decodeHex())\n\t\t}\n\n\t\tfor contract in contracts.keys {\n\t\t\tacct.contracts.add(name: contract, code: contracts[contract]!.decodeHex())\n\t\t}\n\t}\n}\n",
                "args": [
                    {
                        "type": "Array",
                        "value": []
                    },
                    {
                        "type": "Dictionary",
                        "value": []
                    }
                ],
                "referenceBlockId": "a654320e34708197bb572ab523573942dcc35ff70ad7d2b44a5ae76c886d1c7f",
                "gasLimit": 9999,
                "proposalKey": {
                    "address": "f8d6e0586b0a20c7",
                    "keyId": 0,
                    "sequenceNumber": 6
                },
                "payer": "f8d6e0586b0a20c7",
                "authorizers": [
                    "f8d6e0586b0a20c7"
                ],
                "payloadSignatures": [],
                "envelopeSignatures": [
                    {
                        "address": "f8d6e0586b0a20c7",
                        "keyId": 0,
                        "signature": "b324a519b34a9c4b26d5f75828a121cacca1cde60ddccd2dc3b9330b32113e9358d700fc27ff32c3b1bda0cfc92810ab7765bfc2590b7d0838baef94eee55f8b"
                    }
                ],
                "status": {
                    "status": 4,
                    "statusCode": 0,
                    "errorMessage": "",
                    "eventsCount": 6
                }
            }
        ],
        "accounts": [
            {
                "address": "0xf8d6e0586b0a20c7",
                "balance": 999999999999400000,
                "code": "",
                "contracts": {
                    "FlowServiceAccount": "import FungibleToken from 0xee82856bf20e2aa6\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FlowFees from 0xe5a8b7f23e8b548f\nimport FlowStorageFees from 0xf8d6e0586b0a20c7\n\npub contract FlowServiceAccount {\n\n    pub event TransactionFeeUpdated(newFee: UFix64)\n\n    pub event AccountCreationFeeUpdated(newFee: UFix64)\n\n    pub event AccountCreatorAdded(accountCreator: Address)\n\n    pub event AccountCreatorRemoved(accountCreator: Address)\n\n    pub event IsAccountCreationRestrictedUpdated(isRestricted: Bool)\n\n    /// A fixed-rate fee charged to execute a transaction\n    pub var transactionFee: UFix64\n\n    /// A fixed-rate fee charged to create a new account\n    pub var accountCreationFee: UFix64\n\n    /// The list of account addresses that have permission to create accounts\n    access(contract) var accountCreators: {Address: Bool}\n\n    /// Initialize an account with a FlowToken Vault and publish capabilities.\n    pub fun initDefaultToken(_ acct: AuthAccount) {\n        // Create a new FlowToken Vault and save it in storage\n        acct.save(<-FlowToken.createEmptyVault(), to: /storage/flowTokenVault)\n\n        // Create a public capability to the Vault that only exposes\n        // the deposit function through the Receiver interface\n        acct.link<&FlowToken.Vault{FungibleToken.Receiver}>(\n            /public/flowTokenReceiver,\n            target: /storage/flowTokenVault\n        )\n\n        // Create a public capability to the Vault that only exposes\n        // the balance field through the Balance interface\n        acct.link<&FlowToken.Vault{FungibleToken.Balance}>(\n            /public/flowTokenBalance,\n            target: /storage/flowTokenVault\n        )\n    }\n\n    /// Get the default token balance on an account\n    pub fun defaultTokenBalance(_ acct: PublicAccount): UFix64 {\n        let balanceRef = acct\n            .getCapability(/public/flowTokenBalance)\n            .borrow<&FlowToken.Vault{FungibleToken.Balance}>()!\n\n        return balanceRef.balance\n    }\n\n    /// Return a reference to the default token vault on an account\n    pub fun defaultTokenVault(_ acct: AuthAccount): &FlowToken.Vault {\n        return acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Unable to borrow reference to the default token vault\")\n    }\n\n    /// Called when a transaction is submitted to deduct the fee\n    /// from the AuthAccount that submitted it\n    pub fun deductTransactionFee(_ acct: AuthAccount) {\n        if self.transactionFee == UFix64(0) {\n            return\n        }\n\n        let tokenVault = self.defaultTokenVault(acct)\n        let feeVault <- tokenVault.withdraw(amount: self.transactionFee)\n\n        FlowFees.deposit(from: <-feeVault)\n    }\n\n    /// - Deducts the account creation fee from a payer account.\n    /// - Inits the default token.\n    /// - Inits account storage capacity.\n    pub fun setupNewAccount(newAccount: AuthAccount, payer: AuthAccount) {\n        if !FlowServiceAccount.isAccountCreator(payer.address) {\n            panic(\"Account not authorized to create accounts\")\n        }\n\n\n        if self.accountCreationFee < FlowStorageFees.minimumStorageReservation {\n            panic(\"Account creation fees setup incorrectly\")\n        }\n\n        let tokenVault = self.defaultTokenVault(payer)\n        let feeVault <- tokenVault.withdraw(amount: self.accountCreationFee)\n        let storageFeeVault <- (feeVault.withdraw(amount: FlowStorageFees.minimumStorageReservation) as! @FlowToken.Vault)\n        FlowFees.deposit(from: <-feeVault)\n\n        FlowServiceAccount.initDefaultToken(newAccount)\n\n        let vaultRef = FlowServiceAccount.defaultTokenVault(newAccount)\n\n        vaultRef.deposit(from: <-storageFeeVault)\n    }\n\n    /// Returns true if the given address is permitted to create accounts, false otherwise\n    pub fun isAccountCreator(_ address: Address): Bool {\n        // If account creation is not restricted, then anyone can create an account\n        if !self.isAccountCreationRestricted() {\n            return true\n        }\n        return self.accountCreators[address] ?? false\n    }\n\n    /// Is true if new acconts can only be created by approved accounts `self.accountCreators`\n    pub fun isAccountCreationRestricted(): Bool {\n        return self.account.copy<Bool>(from: /storage/isAccountCreationRestricted) ?? false\n    }\n\n    // Authorization resource to change the fields of the contract\n    /// Returns all addresses permitted to create accounts\n    pub fun getAccountCreators(): [Address] {\n        return self.accountCreators.keys\n    }\n\n    /// Authorization resource to change the fields of the contract\n    pub resource Administrator {\n\n        /// Sets the transaction fee\n        pub fun setTransactionFee(_ newFee: UFix64) {\n            FlowServiceAccount.transactionFee = newFee\n            emit TransactionFeeUpdated(newFee: newFee)\n        }\n\n        /// Sets the account creation fee\n        pub fun setAccountCreationFee(_ newFee: UFix64) {\n            FlowServiceAccount.accountCreationFee = newFee\n            emit AccountCreationFeeUpdated(newFee: newFee)\n        }\n\n        /// Adds an account address as an authorized account creator\n        pub fun addAccountCreator(_ accountCreator: Address) {\n            FlowServiceAccount.accountCreators[accountCreator] = true\n            emit AccountCreatorAdded(accountCreator: accountCreator)\n        }\n\n        /// Removes an account address as an authorized account creator\n        pub fun removeAccountCreator(_ accountCreator: Address) {\n            FlowServiceAccount.accountCreators.remove(key: accountCreator)\n            emit AccountCreatorRemoved(accountCreator: accountCreator)\n        }\n\n         pub fun setIsAccountCreationRestricted(_ enabled: Bool) {\n            let path = /storage/isAccountCreationRestricted\n            let oldValue = FlowServiceAccount.account.load<Bool>(from: path)\n            FlowServiceAccount.account.save<Bool>(enabled, to: path)\n            if enabled != oldValue {\n                emit IsAccountCreationRestrictedUpdated(isRestricted: enabled)\n            }\n        }\n    }\n\n    init() {\n        self.transactionFee = 0.0\n        self.accountCreationFee = 0.0\n\n        self.accountCreators = {}\n\n        let admin <- create Administrator()\n        admin.addAccountCreator(self.account.address)\n\n        self.account.save(<-admin, to: /storage/flowServiceAdmin)\n    }\n}\n",
                    "FlowStorageFees": "/*\n * The FlowStorageFees smart contract\n *\n * An account's storage capacity determines up to how much storage on chain it can use. \n * A storage capacity is calculated by multiplying the amount of reserved flow with `StorageFee.storageMegaBytesPerReservedFLOW`\n * The minimum amount of flow tokens reserved for storage capacity is `FlowStorageFees.minimumStorageReservation` this is paid during account creation, by the creator.\n * \n * At the end of all transactions, any account that had any value changed in their storage \n * has their storage capacity checked against their storage used and their main flow token vault against the minimum reservation.\n * If any account fails this check the transaction wil fail.\n * \n * An account moving/deleting its `FlowToken.Vault` resource will result \n * in the transaction failing because the account will have no storage capacity.\n * \n */\n\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FlowToken from 0x0ae53cb6e3f42a79\n\npub contract FlowStorageFees {\n\n    // Emitted when the amount of storage capacity an account has per reserved Flow token changes\n    pub event StorageMegaBytesPerReservedFLOWChanged(_ storageMegaBytesPerReservedFLOW: UFix64)\n\n    // Emitted when the minimum amount of Flow tokens that an account needs to have reserved for storage capacity changes.\n    pub event MinimumStorageReservationChanged(_ minimumStorageReservation: UFix64)\n\n    // Defines how much storage capacity every account has per reserved Flow token.\n    // definition is written per unit of flow instead of the inverse, \n    // so there is no loss of precision calculating storage from flow, \n    // but there is loss of precision when calculating flow per storage.\n    pub var storageMegaBytesPerReservedFLOW: UFix64\n\n    // Defines the minimum amount of Flow tokens that every account needs to have reserved for storage capacity.\n    // If an account has less then this amount reserved by the end of any transaction it participated in, the transaction will fail.\n    pub var minimumStorageReservation: UFix64\n\n    // An administrator resource that can change the parameters of the FlowStorageFees smart contract.\n    pub resource Administrator {\n\n        // Changes the amount of storage capacity an account has per accounts' reserved storage FLOW.\n        pub fun setStorageMegaBytesPerReservedFLOW(_ storageMegaBytesPerReservedFLOW: UFix64) {\n            if FlowStorageFees.storageMegaBytesPerReservedFLOW == storageMegaBytesPerReservedFLOW {\n              return\n            }\n            FlowStorageFees.storageMegaBytesPerReservedFLOW = storageMegaBytesPerReservedFLOW\n            emit StorageMegaBytesPerReservedFLOWChanged(storageMegaBytesPerReservedFLOW)\n        }\n\n        // Changes the minimum amount of FLOW an account has to have reserved.\n        pub fun setMinimumStorageReservation(_ minimumStorageReservation: UFix64) {\n            if FlowStorageFees.minimumStorageReservation == minimumStorageReservation {\n              return\n            }\n            FlowStorageFees.minimumStorageReservation = minimumStorageReservation\n            emit MinimumStorageReservationChanged(minimumStorageReservation)\n        }\n\n        access(contract) init(){}\n    }\n\n    // Returns megabytes\n    pub fun calculateAccountCapacity(_ accountAddress: Address): UFix64 {\n        let balanceRef = getAccount(accountAddress)\n            .getCapability<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance)!\n            .borrow() ?? panic(\"Could not borrow FLOW balance capability\")\n\n        // get address token balance\n        if balanceRef.balance < self.minimumStorageReservation {\n            // if < then minimum return 0\n            return 0.0\n        } else {\n            // return balance multiplied with megabytes per flow \n            return balanceRef.balance * self.storageMegaBytesPerReservedFLOW\n        }\n    }\n\n    // Amount in Flow tokens\n    // Returns megabytes\n    pub fun flowToStorageCapacity(_ amount: UFix64): UFix64 {\n        return amount * FlowStorageFees.storageMegaBytesPerReservedFLOW\n    }\n\n    // Amount in megabytes\n    // Returns Flow tokens\n    pub fun storageCapacityToFlow(_ amount: UFix64): UFix64 {\n        if FlowStorageFees.storageMegaBytesPerReservedFLOW == 0.0 as UFix64 {\n            return 0.0 as UFix64\n        }\n        // possible loss of precision\n        // putting the result back into `flowToStorageCapacity` might not yield the same result\n        return amount / FlowStorageFees.storageMegaBytesPerReservedFLOW\n    }\n\n    // converts storage used from UInt64 Bytes to UFix64 Megabytes.\n    pub fun convertUInt64StorageBytesToUFix64Megabytes(_ storage: UInt64): UFix64 {\n        // safe convert UInt64 to UFix64 (without overflow)\n        let f = UFix64(storage % 100000000 as UInt64) * 0.00000001 as UFix64 + UFix64(storage / 100000000 as UInt64)\n        // decimal point correction. Megabytes to bytes have a conversion of 10^-6 while UFix64 minimum value is 10^-8\n        let storageMb = f * 100.0 as UFix64\n        return storageMb\n    }\n\n    // Gets \"available\" balance of an account\n    // The available balance is its default token balance minus what is reserved for storage.\n    pub fun defaultTokenAvailableBalance(_ accountAddress: Address): UFix64 {\n        //get balance of account\n        let acct = getAccount(accountAddress)\n        let balanceRef = acct\n            .getCapability(/public/flowTokenBalance)\n            .borrow<&FlowToken.Vault{FungibleToken.Balance}>()!\n        let balance = balanceRef.balance\n\n        // get how much should be reserved for storage\n        var reserved = self.storageCapacityToFlow(self.convertUInt64StorageBytesToUFix64Megabytes(acct.storageUsed))\n        // at least self.minimumStorageReservation should be reserved\n        if reserved < self.minimumStorageReservation {\n            reserved = self.minimumStorageReservation\n        }\n\n        // balance could be less that what the account needs to have reserved for storage. In that case return 0.\n        if reserved > balance {\n            return 0.0\n        }\n        \n        return balance - reserved\n    }\n\n    init() {\n        self.storageMegaBytesPerReservedFLOW = 1.0 // 1 Mb per 1 Flow token\n        self.minimumStorageReservation = 0.0 // or 0 kb of minimum storage reservation\n\n        let admin <- create Administrator()\n        self.account.save(<-admin, to: /storage/storageFeesAdmin)\n    }\n}",
                    "HelloWorld": "// HelloWorld.cdc\n//\n// Welcome to Cadence! This is one of the simplest programs you can deploy on Flow.\n//\n// The HelloWorld contract contains a single string field and a public getter function.\n//\n// Follow the \"Hello, World!\" tutorial to learn more: https://docs.onflow.org/docs/hello-world\n\npub contract HelloWorld {\n\n    // Declare a public field of type String.\n    //\n    // All fields must be initialized in the init() function.\n    pub let greeting: String\n\n    pub event Greet(x: String)\n\n    // The init() function is required if the contract contains any fields.\n    init() {\n        self.greeting = \"Hello, World!\"\n    }\n\n    // Public function that returns our friendly greeting!\n    pub fun hello(): String {\n        emit Greet(x: self.greeting)\n        return self.greeting\n    }\n}\n"
                },
                "keys": [
                    {
                        "index": 0,
                        "publicKey": "ee69a34c1a8c4fdc5d55bd1a78174ef1fd5f579243ecb032672cbb23845973d4b8c393078807b820dcf6a4573dbca61dcfffc2ceca1af3d2bc03eac31fdbe67c",
                        "signAlgo": 2,
                        "hashAlgo": 3,
                        "weight": 1000,
                        "sequenceNumber": 8,
                        "revoked": false
                    }
                ]
            }
        ],
        "events": [
            [
                {
                    "transactionId": "e598ff0fbc5160f1781490db76b25884d435e477a9bbfa1c0733bd045b136c74",
                    "type": "A.0ae53cb6e3f42a79.FlowToken.TokensWithdrawn",
                    "transactionIndex": 1,
                    "eventIndex": 0,
                    "data": {
                        "amount": "0.00100000",
                        "from": "0xf8d6e0586b0a20c7"
                    }
                },
                {
                    "transactionId": "e598ff0fbc5160f1781490db76b25884d435e477a9bbfa1c0733bd045b136c74",
                    "type": "A.0ae53cb6e3f42a79.FlowToken.TokensWithdrawn",
                    "transactionIndex": 1,
                    "eventIndex": 1,
                    "data": {
                        "amount": "0.00100000",
                        "from": null
                    }
                },
                {
                    "transactionId": "e598ff0fbc5160f1781490db76b25884d435e477a9bbfa1c0733bd045b136c74",
                    "type": "A.0ae53cb6e3f42a79.FlowToken.TokensDeposited",
                    "transactionIndex": 1,
                    "eventIndex": 2,
                    "data": {
                        "amount": "0.00000000",
                        "to": "0xe5a8b7f23e8b548f"
                    }
                },
                {
                    "transactionId": "e598ff0fbc5160f1781490db76b25884d435e477a9bbfa1c0733bd045b136c74",
                    "type": "A.e5a8b7f23e8b548f.FlowFees.TokensDeposited",
                    "transactionIndex": 1,
                    "eventIndex": 3,
                    "data": {
                        "amount": "0.00000000"
                    }
                },
                {
                    "transactionId": "e598ff0fbc5160f1781490db76b25884d435e477a9bbfa1c0733bd045b136c74",
                    "type": "A.0ae53cb6e3f42a79.FlowToken.TokensDeposited",
                    "transactionIndex": 1,
                    "eventIndex": 4,
                    "data": {
                        "amount": "0.00100000",
                        "to": "0x179b6b1cb6755e31"
                    }
                },
                {
                    "transactionId": "e598ff0fbc5160f1781490db76b25884d435e477a9bbfa1c0733bd045b136c74",
                    "type": "flow.AccountCreated",
                    "transactionIndex": 1,
                    "eventIndex": 5,
                    "data": {
                        "address": "0x179b6b1cb6755e31"
                    }
                }
            ]
        ]
    },
    {
        "block": {
            "id": "3ba742717367af2ff24a48a39b73c79319840c3ce170ff1280a35310bf005c2d",
            "parentId": "47858e7fd972adbd918c3bbca7adbfb28a7b078437cb958eda5f719b56a98326",
            "height": 9,
            "timestamp": "2021-10-03T10:07:52.459Z",
            "collectionGuarantees": [
                {
                    "collectionId": "278a0eda54714cc73809dbdb3b8e5862facde19321fae2eafc11369def040545",
                    "signatures": [
                        ""
                    ]
                }
            ],
            "blockSeals": [],
            "signatures": [
                ""
            ]
        },
        "collections": [
            {
                "blockId": "3ba742717367af2ff24a48a39b73c79319840c3ce170ff1280a35310bf005c2d",
                "id": "278a0eda54714cc73809dbdb3b8e5862facde19321fae2eafc11369def040545",
                "transactionIds": [
                    "c33b6818249978cc344f4c2f1d7cabbc5d1380d0263094b6e1de5b39dd549a11"
                ]
            }
        ],
        "transactions": [
            {
                "id": "c33b6818249978cc344f4c2f1d7cabbc5d1380d0263094b6e1de5b39dd549a11",
                "script": "\ntransaction(publicKeys: [String], contracts: {String: String}) {\n\tprepare(signer: AuthAccount) {\n\t\tlet acct = AuthAccount(payer: signer)\n\n\t\tfor key in publicKeys {\n\t\t\tacct.addPublicKey(key.decodeHex())\n\t\t}\n\n\t\tfor contract in contracts.keys {\n\t\t\tacct.contracts.add(name: contract, code: contracts[contract]!.decodeHex())\n\t\t}\n\t}\n}\n",
                "args": [
                    {
                        "type": "Array",
                        "value": [
                            {
                                "type": "String",
                                "value": "f847b8409dafb81fc5baf4133ca2c0f481495b229b298c8f59898f6e0d8238a262adf9fe23d44bbaa2a83889e951eaf9c52f23c788f12fa9418bb452a69e5ca79760af5702038203e8"
                            }
                        ]
                    },
                    {
                        "type": "Dictionary",
                        "value": []
                    }
                ],
                "referenceBlockId": "47858e7fd972adbd918c3bbca7adbfb28a7b078437cb958eda5f719b56a98326",
                "gasLimit": 9999,
                "proposalKey": {
                    "address": "f8d6e0586b0a20c7",
                    "keyId": 0,
                    "sequenceNumber": 7
                },
                "payer": "f8d6e0586b0a20c7",
                "authorizers": [
                    "f8d6e0586b0a20c7"
                ],
                "payloadSignatures": [],
                "envelopeSignatures": [
                    {
                        "address": "f8d6e0586b0a20c7",
                        "keyId": 0,
                        "signature": "88e5f2a5aee759b2b1946cab5f702e65a73a89b5a0cc5ebc501098c83d07111dcd27dba1cd8b059ec56d42baa74d7faae717de0486ced17491f1be8953dc955c"
                    }
                ],
                "status": {
                    "status": 4,
                    "statusCode": 0,
                    "errorMessage": "",
                    "eventsCount": 7
                }
            }
        ],
        "accounts": [
            {
                "address": "0xf8d6e0586b0a20c7",
                "balance": 999999999999400000,
                "code": "",
                "contracts": {
                    "FlowServiceAccount": "import FungibleToken from 0xee82856bf20e2aa6\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FlowFees from 0xe5a8b7f23e8b548f\nimport FlowStorageFees from 0xf8d6e0586b0a20c7\n\npub contract FlowServiceAccount {\n\n    pub event TransactionFeeUpdated(newFee: UFix64)\n\n    pub event AccountCreationFeeUpdated(newFee: UFix64)\n\n    pub event AccountCreatorAdded(accountCreator: Address)\n\n    pub event AccountCreatorRemoved(accountCreator: Address)\n\n    pub event IsAccountCreationRestrictedUpdated(isRestricted: Bool)\n\n    /// A fixed-rate fee charged to execute a transaction\n    pub var transactionFee: UFix64\n\n    /// A fixed-rate fee charged to create a new account\n    pub var accountCreationFee: UFix64\n\n    /// The list of account addresses that have permission to create accounts\n    access(contract) var accountCreators: {Address: Bool}\n\n    /// Initialize an account with a FlowToken Vault and publish capabilities.\n    pub fun initDefaultToken(_ acct: AuthAccount) {\n        // Create a new FlowToken Vault and save it in storage\n        acct.save(<-FlowToken.createEmptyVault(), to: /storage/flowTokenVault)\n\n        // Create a public capability to the Vault that only exposes\n        // the deposit function through the Receiver interface\n        acct.link<&FlowToken.Vault{FungibleToken.Receiver}>(\n            /public/flowTokenReceiver,\n            target: /storage/flowTokenVault\n        )\n\n        // Create a public capability to the Vault that only exposes\n        // the balance field through the Balance interface\n        acct.link<&FlowToken.Vault{FungibleToken.Balance}>(\n            /public/flowTokenBalance,\n            target: /storage/flowTokenVault\n        )\n    }\n\n    /// Get the default token balance on an account\n    pub fun defaultTokenBalance(_ acct: PublicAccount): UFix64 {\n        let balanceRef = acct\n            .getCapability(/public/flowTokenBalance)\n            .borrow<&FlowToken.Vault{FungibleToken.Balance}>()!\n\n        return balanceRef.balance\n    }\n\n    /// Return a reference to the default token vault on an account\n    pub fun defaultTokenVault(_ acct: AuthAccount): &FlowToken.Vault {\n        return acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Unable to borrow reference to the default token vault\")\n    }\n\n    /// Called when a transaction is submitted to deduct the fee\n    /// from the AuthAccount that submitted it\n    pub fun deductTransactionFee(_ acct: AuthAccount) {\n        if self.transactionFee == UFix64(0) {\n            return\n        }\n\n        let tokenVault = self.defaultTokenVault(acct)\n        let feeVault <- tokenVault.withdraw(amount: self.transactionFee)\n\n        FlowFees.deposit(from: <-feeVault)\n    }\n\n    /// - Deducts the account creation fee from a payer account.\n    /// - Inits the default token.\n    /// - Inits account storage capacity.\n    pub fun setupNewAccount(newAccount: AuthAccount, payer: AuthAccount) {\n        if !FlowServiceAccount.isAccountCreator(payer.address) {\n            panic(\"Account not authorized to create accounts\")\n        }\n\n\n        if self.accountCreationFee < FlowStorageFees.minimumStorageReservation {\n            panic(\"Account creation fees setup incorrectly\")\n        }\n\n        let tokenVault = self.defaultTokenVault(payer)\n        let feeVault <- tokenVault.withdraw(amount: self.accountCreationFee)\n        let storageFeeVault <- (feeVault.withdraw(amount: FlowStorageFees.minimumStorageReservation) as! @FlowToken.Vault)\n        FlowFees.deposit(from: <-feeVault)\n\n        FlowServiceAccount.initDefaultToken(newAccount)\n\n        let vaultRef = FlowServiceAccount.defaultTokenVault(newAccount)\n\n        vaultRef.deposit(from: <-storageFeeVault)\n    }\n\n    /// Returns true if the given address is permitted to create accounts, false otherwise\n    pub fun isAccountCreator(_ address: Address): Bool {\n        // If account creation is not restricted, then anyone can create an account\n        if !self.isAccountCreationRestricted() {\n            return true\n        }\n        return self.accountCreators[address] ?? false\n    }\n\n    /// Is true if new acconts can only be created by approved accounts `self.accountCreators`\n    pub fun isAccountCreationRestricted(): Bool {\n        return self.account.copy<Bool>(from: /storage/isAccountCreationRestricted) ?? false\n    }\n\n    // Authorization resource to change the fields of the contract\n    /// Returns all addresses permitted to create accounts\n    pub fun getAccountCreators(): [Address] {\n        return self.accountCreators.keys\n    }\n\n    /// Authorization resource to change the fields of the contract\n    pub resource Administrator {\n\n        /// Sets the transaction fee\n        pub fun setTransactionFee(_ newFee: UFix64) {\n            FlowServiceAccount.transactionFee = newFee\n            emit TransactionFeeUpdated(newFee: newFee)\n        }\n\n        /// Sets the account creation fee\n        pub fun setAccountCreationFee(_ newFee: UFix64) {\n            FlowServiceAccount.accountCreationFee = newFee\n            emit AccountCreationFeeUpdated(newFee: newFee)\n        }\n\n        /// Adds an account address as an authorized account creator\n        pub fun addAccountCreator(_ accountCreator: Address) {\n            FlowServiceAccount.accountCreators[accountCreator] = true\n            emit AccountCreatorAdded(accountCreator: accountCreator)\n        }\n\n        /// Removes an account address as an authorized account creator\n        pub fun removeAccountCreator(_ accountCreator: Address) {\n            FlowServiceAccount.accountCreators.remove(key: accountCreator)\n            emit AccountCreatorRemoved(accountCreator: accountCreator)\n        }\n\n         pub fun setIsAccountCreationRestricted(_ enabled: Bool) {\n            let path = /storage/isAccountCreationRestricted\n            let oldValue = FlowServiceAccount.account.load<Bool>(from: path)\n            FlowServiceAccount.account.save<Bool>(enabled, to: path)\n            if enabled != oldValue {\n                emit IsAccountCreationRestrictedUpdated(isRestricted: enabled)\n            }\n        }\n    }\n\n    init() {\n        self.transactionFee = 0.0\n        self.accountCreationFee = 0.0\n\n        self.accountCreators = {}\n\n        let admin <- create Administrator()\n        admin.addAccountCreator(self.account.address)\n\n        self.account.save(<-admin, to: /storage/flowServiceAdmin)\n    }\n}\n",
                    "FlowStorageFees": "/*\n * The FlowStorageFees smart contract\n *\n * An account's storage capacity determines up to how much storage on chain it can use. \n * A storage capacity is calculated by multiplying the amount of reserved flow with `StorageFee.storageMegaBytesPerReservedFLOW`\n * The minimum amount of flow tokens reserved for storage capacity is `FlowStorageFees.minimumStorageReservation` this is paid during account creation, by the creator.\n * \n * At the end of all transactions, any account that had any value changed in their storage \n * has their storage capacity checked against their storage used and their main flow token vault against the minimum reservation.\n * If any account fails this check the transaction wil fail.\n * \n * An account moving/deleting its `FlowToken.Vault` resource will result \n * in the transaction failing because the account will have no storage capacity.\n * \n */\n\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FlowToken from 0x0ae53cb6e3f42a79\n\npub contract FlowStorageFees {\n\n    // Emitted when the amount of storage capacity an account has per reserved Flow token changes\n    pub event StorageMegaBytesPerReservedFLOWChanged(_ storageMegaBytesPerReservedFLOW: UFix64)\n\n    // Emitted when the minimum amount of Flow tokens that an account needs to have reserved for storage capacity changes.\n    pub event MinimumStorageReservationChanged(_ minimumStorageReservation: UFix64)\n\n    // Defines how much storage capacity every account has per reserved Flow token.\n    // definition is written per unit of flow instead of the inverse, \n    // so there is no loss of precision calculating storage from flow, \n    // but there is loss of precision when calculating flow per storage.\n    pub var storageMegaBytesPerReservedFLOW: UFix64\n\n    // Defines the minimum amount of Flow tokens that every account needs to have reserved for storage capacity.\n    // If an account has less then this amount reserved by the end of any transaction it participated in, the transaction will fail.\n    pub var minimumStorageReservation: UFix64\n\n    // An administrator resource that can change the parameters of the FlowStorageFees smart contract.\n    pub resource Administrator {\n\n        // Changes the amount of storage capacity an account has per accounts' reserved storage FLOW.\n        pub fun setStorageMegaBytesPerReservedFLOW(_ storageMegaBytesPerReservedFLOW: UFix64) {\n            if FlowStorageFees.storageMegaBytesPerReservedFLOW == storageMegaBytesPerReservedFLOW {\n              return\n            }\n            FlowStorageFees.storageMegaBytesPerReservedFLOW = storageMegaBytesPerReservedFLOW\n            emit StorageMegaBytesPerReservedFLOWChanged(storageMegaBytesPerReservedFLOW)\n        }\n\n        // Changes the minimum amount of FLOW an account has to have reserved.\n        pub fun setMinimumStorageReservation(_ minimumStorageReservation: UFix64) {\n            if FlowStorageFees.minimumStorageReservation == minimumStorageReservation {\n              return\n            }\n            FlowStorageFees.minimumStorageReservation = minimumStorageReservation\n            emit MinimumStorageReservationChanged(minimumStorageReservation)\n        }\n\n        access(contract) init(){}\n    }\n\n    // Returns megabytes\n    pub fun calculateAccountCapacity(_ accountAddress: Address): UFix64 {\n        let balanceRef = getAccount(accountAddress)\n            .getCapability<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance)!\n            .borrow() ?? panic(\"Could not borrow FLOW balance capability\")\n\n        // get address token balance\n        if balanceRef.balance < self.minimumStorageReservation {\n            // if < then minimum return 0\n            return 0.0\n        } else {\n            // return balance multiplied with megabytes per flow \n            return balanceRef.balance * self.storageMegaBytesPerReservedFLOW\n        }\n    }\n\n    // Amount in Flow tokens\n    // Returns megabytes\n    pub fun flowToStorageCapacity(_ amount: UFix64): UFix64 {\n        return amount * FlowStorageFees.storageMegaBytesPerReservedFLOW\n    }\n\n    // Amount in megabytes\n    // Returns Flow tokens\n    pub fun storageCapacityToFlow(_ amount: UFix64): UFix64 {\n        if FlowStorageFees.storageMegaBytesPerReservedFLOW == 0.0 as UFix64 {\n            return 0.0 as UFix64\n        }\n        // possible loss of precision\n        // putting the result back into `flowToStorageCapacity` might not yield the same result\n        return amount / FlowStorageFees.storageMegaBytesPerReservedFLOW\n    }\n\n    // converts storage used from UInt64 Bytes to UFix64 Megabytes.\n    pub fun convertUInt64StorageBytesToUFix64Megabytes(_ storage: UInt64): UFix64 {\n        // safe convert UInt64 to UFix64 (without overflow)\n        let f = UFix64(storage % 100000000 as UInt64) * 0.00000001 as UFix64 + UFix64(storage / 100000000 as UInt64)\n        // decimal point correction. Megabytes to bytes have a conversion of 10^-6 while UFix64 minimum value is 10^-8\n        let storageMb = f * 100.0 as UFix64\n        return storageMb\n    }\n\n    // Gets \"available\" balance of an account\n    // The available balance is its default token balance minus what is reserved for storage.\n    pub fun defaultTokenAvailableBalance(_ accountAddress: Address): UFix64 {\n        //get balance of account\n        let acct = getAccount(accountAddress)\n        let balanceRef = acct\n            .getCapability(/public/flowTokenBalance)\n            .borrow<&FlowToken.Vault{FungibleToken.Balance}>()!\n        let balance = balanceRef.balance\n\n        // get how much should be reserved for storage\n        var reserved = self.storageCapacityToFlow(self.convertUInt64StorageBytesToUFix64Megabytes(acct.storageUsed))\n        // at least self.minimumStorageReservation should be reserved\n        if reserved < self.minimumStorageReservation {\n            reserved = self.minimumStorageReservation\n        }\n\n        // balance could be less that what the account needs to have reserved for storage. In that case return 0.\n        if reserved > balance {\n            return 0.0\n        }\n        \n        return balance - reserved\n    }\n\n    init() {\n        self.storageMegaBytesPerReservedFLOW = 1.0 // 1 Mb per 1 Flow token\n        self.minimumStorageReservation = 0.0 // or 0 kb of minimum storage reservation\n\n        let admin <- create Administrator()\n        self.account.save(<-admin, to: /storage/storageFeesAdmin)\n    }\n}",
                    "HelloWorld": "// HelloWorld.cdc\n//\n// Welcome to Cadence! This is one of the simplest programs you can deploy on Flow.\n//\n// The HelloWorld contract contains a single string field and a public getter function.\n//\n// Follow the \"Hello, World!\" tutorial to learn more: https://docs.onflow.org/docs/hello-world\n\npub contract HelloWorld {\n\n    // Declare a public field of type String.\n    //\n    // All fields must be initialized in the init() function.\n    pub let greeting: String\n\n    pub event Greet(x: String)\n\n    // The init() function is required if the contract contains any fields.\n    init() {\n        self.greeting = \"Hello, World!\"\n    }\n\n    // Public function that returns our friendly greeting!\n    pub fun hello(): String {\n        emit Greet(x: self.greeting)\n        return self.greeting\n    }\n}\n"
                },
                "keys": [
                    {
                        "index": 0,
                        "publicKey": "ee69a34c1a8c4fdc5d55bd1a78174ef1fd5f579243ecb032672cbb23845973d4b8c393078807b820dcf6a4573dbca61dcfffc2ceca1af3d2bc03eac31fdbe67c",
                        "signAlgo": 2,
                        "hashAlgo": 3,
                        "weight": 1000,
                        "sequenceNumber": 8,
                        "revoked": false
                    }
                ]
            }
        ],
        "events": [
            [
                {
                    "transactionId": "c33b6818249978cc344f4c2f1d7cabbc5d1380d0263094b6e1de5b39dd549a11",
                    "type": "A.0ae53cb6e3f42a79.FlowToken.TokensWithdrawn",
                    "transactionIndex": 1,
                    "eventIndex": 0,
                    "data": {
                        "amount": "0.00100000",
                        "from": "0xf8d6e0586b0a20c7"
                    }
                },
                {
                    "transactionId": "c33b6818249978cc344f4c2f1d7cabbc5d1380d0263094b6e1de5b39dd549a11",
                    "type": "A.0ae53cb6e3f42a79.FlowToken.TokensWithdrawn",
                    "transactionIndex": 1,
                    "eventIndex": 1,
                    "data": {
                        "amount": "0.00100000",
                        "from": null
                    }
                },
                {
                    "transactionId": "c33b6818249978cc344f4c2f1d7cabbc5d1380d0263094b6e1de5b39dd549a11",
                    "type": "A.0ae53cb6e3f42a79.FlowToken.TokensDeposited",
                    "transactionIndex": 1,
                    "eventIndex": 2,
                    "data": {
                        "amount": "0.00000000",
                        "to": "0xe5a8b7f23e8b548f"
                    }
                },
                {
                    "transactionId": "c33b6818249978cc344f4c2f1d7cabbc5d1380d0263094b6e1de5b39dd549a11",
                    "type": "A.e5a8b7f23e8b548f.FlowFees.TokensDeposited",
                    "transactionIndex": 1,
                    "eventIndex": 3,
                    "data": {
                        "amount": "0.00000000"
                    }
                },
                {
                    "transactionId": "c33b6818249978cc344f4c2f1d7cabbc5d1380d0263094b6e1de5b39dd549a11",
                    "type": "A.0ae53cb6e3f42a79.FlowToken.TokensDeposited",
                    "transactionIndex": 1,
                    "eventIndex": 4,
                    "data": {
                        "amount": "0.00100000",
                        "to": "0xf3fcd2c1a78f5eee"
                    }
                },
                {
                    "transactionId": "c33b6818249978cc344f4c2f1d7cabbc5d1380d0263094b6e1de5b39dd549a11",
                    "type": "flow.AccountCreated",
                    "transactionIndex": 1,
                    "eventIndex": 5,
                    "data": {
                        "address": "0xf3fcd2c1a78f5eee"
                    }
                },
                {
                    "transactionId": "c33b6818249978cc344f4c2f1d7cabbc5d1380d0263094b6e1de5b39dd549a11",
                    "type": "flow.AccountKeyAdded",
                    "transactionIndex": 1,
                    "eventIndex": 6,
                    "data": {
                        "address": "0xf3fcd2c1a78f5eee",
                        "publicKey": [
                            248,
                            71,
                            184,
                            64,
                            157,
                            175,
                            184,
                            31,
                            197,
                            186,
                            244,
                            19,
                            60,
                            162,
                            192,
                            244,
                            129,
                            73,
                            91,
                            34,
                            155,
                            41,
                            140,
                            143,
                            89,
                            137,
                            143,
                            110,
                            13,
                            130,
                            56,
                            162,
                            98,
                            173,
                            249,
                            254,
                            35,
                            212,
                            75,
                            186,
                            162,
                            168,
                            56,
                            137,
                            233,
                            81,
                            234,
                            249,
                            197,
                            47,
                            35,
                            199,
                            136,
                            241,
                            47,
                            169,
                            65,
                            139,
                            180,
                            82,
                            166,
                            158,
                            92,
                            167,
                            151,
                            96,
                            175,
                            87,
                            2,
                            3,
                            130,
                            3,
                            232
                        ]
                    }
                }
            ]
        ]
    },
    {
        "block": {
            "id": "10226512779eda788e7b21dbe193b082a97ef119714088957641cc55e15854d9",
            "parentId": "3ba742717367af2ff24a48a39b73c79319840c3ce170ff1280a35310bf005c2d",
            "height": 10,
            "timestamp": "2021-10-03T10:09:01.919Z",
            "collectionGuarantees": [
                {
                    "collectionId": "6041edb02054e33a2a16be4959de0c63836cee6ebc77ff14dc6ad4e2f3368a83",
                    "signatures": [
                        ""
                    ]
                }
            ],
            "blockSeals": [],
            "signatures": [
                ""
            ]
        },
        "collections": [
            {
                "blockId": "10226512779eda788e7b21dbe193b082a97ef119714088957641cc55e15854d9",
                "id": "6041edb02054e33a2a16be4959de0c63836cee6ebc77ff14dc6ad4e2f3368a83",
                "transactionIds": [
                    "b8e6f6fefa7cedfb93303fb63f28ee9e6d487e5882e978561d1ee7f664c0d8c4"
                ]
            }
        ],
        "transactions": [
            {
                "id": "b8e6f6fefa7cedfb93303fb63f28ee9e6d487e5882e978561d1ee7f664c0d8c4",
                "script": "\n\ttransaction(name: String, code: String ) {\n\t\tprepare(signer: AuthAccount) {\n\t\t\tsigner.contracts.add(name: name, code: code.decodeHex() )\n\t\t}\n\t}",
                "args": [
                    {
                        "type": "String",
                        "value": "HelloWorld"
                    },
                    {
                        "type": "String",
                        "value": "2f2f2048656c6c6f576f726c642e6364630a2f2f0a2f2f2057656c636f6d6520746f20436164656e6365212054686973206973206f6e65206f66207468652073696d706c6573742070726f6772616d7320796f752063616e206465706c6f79206f6e20466c6f772e0a2f2f0a2f2f205468652048656c6c6f576f726c6420636f6e747261637420636f6e7461696e7320612073696e676c6520737472696e67206669656c6420616e642061207075626c6963206765747465722066756e6374696f6e2e0a2f2f0a2f2f20466f6c6c6f7720746865202248656c6c6f2c20576f726c642122207475746f7269616c20746f206c6561726e206d6f72653a2068747470733a2f2f646f63732e6f6e666c6f772e6f72672f646f63732f68656c6c6f2d776f726c640a0a70756220636f6e74726163742048656c6c6f576f726c64207b0a0a202020202f2f204465636c6172652061207075626c6963206669656c64206f66207479706520537472696e672e0a202020202f2f0a202020202f2f20416c6c206669656c6473206d75737420626520696e697469616c697a656420696e2074686520696e697428292066756e6374696f6e2e0a20202020707562206c6574206772656574696e673a20537472696e670a0a202020202f2f2054686520696e697428292066756e6374696f6e2069732072657175697265642069662074686520636f6e747261637420636f6e7461696e7320616e79206669656c64732e0a20202020696e69742829207b0a202020202020202073656c662e6772656574696e67203d202248656c6c6f2c20576f726c6421220a202020207d0a0a202020202f2f205075626c69632066756e6374696f6e20746861742072657475726e73206f757220667269656e646c79206772656574696e67210a202020207075622066756e2068656c6c6f28293a20537472696e67207b0a202020202020202072657475726e2073656c662e6772656574696e670a202020207d0a7d0a"
                    }
                ],
                "referenceBlockId": "3ba742717367af2ff24a48a39b73c79319840c3ce170ff1280a35310bf005c2d",
                "gasLimit": 9999,
                "proposalKey": {
                    "address": "f3fcd2c1a78f5eee",
                    "keyId": 0,
                    "sequenceNumber": 0
                },
                "payer": "f3fcd2c1a78f5eee",
                "authorizers": [
                    "f3fcd2c1a78f5eee"
                ],
                "payloadSignatures": [],
                "envelopeSignatures": [
                    {
                        "address": "f3fcd2c1a78f5eee",
                        "keyId": 0,
                        "signature": "5b9fef6b66f098be17887a3c4039119a8ba92dd6f7afedb012eb5a157b36a4efc97b6dcf362fdcb5317d361a8b5a84ca03e70a4d05be9cce7630ecf476718752"
                    }
                ],
                "status": {
                    "status": 4,
                    "statusCode": 0,
                    "errorMessage": "",
                    "eventsCount": 1
                }
            }
        ],
        "accounts": [
            {
                "address": "0xf3fcd2c1a78f5eee",
                "balance": 100000,
                "code": "",
                "contracts": {
                    "HelloWorld": "// HelloWorld.cdc\n//\n// Welcome to Cadence! This is one of the simplest programs you can deploy on Flow.\n//\n// The HelloWorld contract contains a single string field and a public getter function.\n//\n// Follow the \"Hello, World!\" tutorial to learn more: https://docs.onflow.org/docs/hello-world\n\npub contract HelloWorld {\n\n    // Declare a public field of type String.\n    //\n    // All fields must be initialized in the init() function.\n    pub let greeting: String\n\n    // The init() function is required if the contract contains any fields.\n    init() {\n        self.greeting = \"Hello, World!\"\n    }\n\n    // Public function that returns our friendly greeting!\n    pub fun hello(): String {\n        return self.greeting\n    }\n}\n"
                },
                "keys": [
                    {
                        "index": 0,
                        "publicKey": "9dafb81fc5baf4133ca2c0f481495b229b298c8f59898f6e0d8238a262adf9fe23d44bbaa2a83889e951eaf9c52f23c788f12fa9418bb452a69e5ca79760af57",
                        "signAlgo": 2,
                        "hashAlgo": 3,
                        "weight": 1000,
                        "sequenceNumber": 1,
                        "revoked": false
                    }
                ]
            }
        ],
        "events": [
            [
                {
                    "transactionId": "b8e6f6fefa7cedfb93303fb63f28ee9e6d487e5882e978561d1ee7f664c0d8c4",
                    "type": "flow.AccountContractAdded",
                    "transactionIndex": 1,
                    "eventIndex": 0,
                    "data": {
                        "address": "0xf3fcd2c1a78f5eee",
                        "codeHash": [
                            129,
                            238,
                            73,
                            113,
                            52,
                            140,
                            114,
                            4,
                            75,
                            174,
                            78,
                            27,
                            8,
                            160,
                            90,
                            194,
                            179,
                            160,
                            58,
                            122,
                            195,
                            214,
                            48,
                            111,
                            13,
                            65,
                            177,
                            222,
                            181,
                            181,
                            154,
                            209
                        ],
                        "contract": "HelloWorld"
                    }
                }
            ]
        ]
    }
]